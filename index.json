[
{
	"uri": "/basics_of_computer_science/",
	"title": "Basics C.S.",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Basics C.S. Basics Computer Science\n전산 기초에 관한 내용입니다.\n\r개발상식\r\r\r네트워크\r\r\r운영체제\r\r\r데이터베이스\r\r\r디자인패턴\r\r\r알고리즘\r\r\r"
},
{
	"uri": "/ci_cd/ci/",
	"title": "CI",
	"tags": [],
	"description": "",
	"content": "CI ( Continuous Integration, 지속적인 통합 ) CI 란 팀의 구성원들이 작업한 내용을 정기적으로 통합하는 것을 의미한다.\n풀어서 이야기하면 소프트웨어가 거대해지고 복잡해지면서 팀 단위로 개발을 하게 되었고 분업과 협업이 필수가 되면서 하나의 프로젝트를 여러 명으로 구성된 한 팀이 작업을 하게 되고 분업과 협업 과정에서 일을 나눠 각각 할당된 부분만 작업을 하게 되었다. CI 시스템을 구축하지 않은 경우 개발자들이 각자 개발한 소스코드를 형상관리 서버에 커밋하면 별도의 품질관리를 거치지 않고, 대부분 개발이 끝난 막바지에 통합을 하여 테스트를 진행하게 된다. 반면 CI 시스템을 구축하게 되면 CI 서버는 형상관리 서버에 Commit된 소스코드를 주기적으로 폴링하여 컴파일, 단위테스트, 코드 인스펙션 등의 과정을 수행하며 신규 또는 수정된 소스코드가 결함이 있는지 여부를 지속적으로 검증한다. 검증 결과는 이메일, RSS 등의 피드백 메커니즘을 통해 개발자들에게 전달되고, 이를 통해 조기에 결함을 발견하여 해결 할 수 있는것이다.\nCI 시스템 구축을 위한 핵심 구성요소 CI Server 빌드 프로세스를 관리하는 서버로 Jenkins 가 여기에 속한다.\nex \u0026gt; Jenkins, Travis CI, etc\nSCM( Source Code Management ) 소스코드 형상 관리 시스템으로 Git 이 여기에 속한다. 소스코드의 개정과 벅업 절차를 자동화하여 오류수정 과장을 돕는다. 팀 프로젝트의 경우 각자 수정한 부분을 전체가 자동으로 동기화 할 수 있는 시스템이다.\nex \u0026gt; Subversion, Git, etc\nbuild Tool 컴파일, 테스트, 정적 분석 등을 실시해 동작 가능한 소프트웨어를 생성하는 도구로 Maven 이 여기에 속한다. 빌드는 형상 관리 시스템에 있는 소스코드를 가져와 컴파일 하여 실행 가능한 파일로 만드는 일련의 과정을 일컫는 말이다.\nex \u0026gt; Maven, Gradle, Ant, make, etc\nTest Tool 작성된 테스트 코드에 따라 자동으로 테스트를 수행해주는 도구로 빌드 툴의 스크립트에서 실행되며 JUnit이 여기에 해당한다.\n빌드 스크립트를 통한 CI/CD 자동화 수행 절차  소스코드를 바이너리 파일로 컴파일한다. 바이너리 파일을 배포 형태로 패키징한다. 단위 테스트를 수행한다. 정적 분석을 수행한다. 분석 결과를 리포팅한다. 패키징한 파일을 테스트 서버에 배포한다.  "
},
{
	"uri": "/java/collection/",
	"title": "Collection",
	"tags": [],
	"description": "",
	"content": "Collection Java Collection 에는 List, Map, Set 인터페이스를 기준으로 여러 구현체가 존재한다. 이에 더해 Stack과 Queue 인터페이스도 존재한다. 왜 이러한 Collection 을 사용하는 것일까? 그 이유는 다수의 Data 를 다루는데 표준화된 클래스들을 제공해주기 때문에 DataStructure 를 직접 구현하지 않고 편하게 사용할 수 있기 때문이다. 또한 배열과 다르게 객체를 보관하기 위한 공간을 미리 정하지 않아도 되므로, 상황에 따라 객체의 수를 동적으로 정할 수 있다. 이는 프로그램의 공간적인 효율성 또한 높여준다.\n List  List 인터페이스를 직접 @Override를 통해 사용자가 정의하여 사용할 수도 있으며, 대표적인 구현체로는 ArrayList가 존재한다. 이는 기존에 있었던 Vector를 개선한 것이다. 이외에도 LinkedList 등의 구현체가 있다.   Map  대표적인 구현체로 HashMap이 존재한다. (밑에서 살펴볼 멀티스레드 환경에서의 개발 부분에서 HashTable 과의 차이점에 대해 살펴본다.) key-value 의 구조로 이루어져 있으며 Map 에 대한 구체적인 내용은 DataStructure 부분의 hashtable 과 일치한다. key 를 기준으로 중복된 값을 저장하지 않으며 순서를 보장하지 않는다. key 에 대해서 순서를 보장하기 위해서는 LinkedHashMap을 사용한다.   Set  대표적인 구현체로 HashSet이 존재한다. value에 대해서 중복된 값을 저장하지 않는다. 사실 Set 자료구조는 Map 의 key-value 구조에서 key 대신에 value 가 들어가 value 를 key 로 하는 자료구조일 뿐이다. 마찬가지로 순서를 보장하지 않으며 순서를 보장해주기 위해서는 LinkedHashSet을 사용한다.   Stack 과 Queue  Stack 객체는 직접 new 키워드로 사용할 수 있으며, Queue 인터페이스는 JDK 1.5 부터 LinkedList에 new 키워드를 적용하여 사용할 수 있다. 자세한 부분은 DataStructure 부분의 설명을 참고하면 된다.    "
},
{
	"uri": "/linux/concept/",
	"title": "Concept",
	"tags": [],
	"description": "",
	"content": "Linux 스웨덴계 핀란드인 리누스 토르발즈(Linus Torvalds)가 1991년 11월에 공개한 유닉스 기반 개인컴퓨터용 공개 운영체제입니다. 유닉스가 유료이다보니, 유닉스와 거의 유사한 환경을 제공하면서 무료라는 장점을가진 리눅스가 프로그램 개발자 및 학교 등에서 급속히 확대되고 있습니다.\n리눅스의 종류 리눅스는 누구나 수정, 배포가 가능하기때문에 수백여개의 리눅스가 존재한다고 합니다. 그중에서도 페도라(Fedora)나 센트오에스(CentOS) 우분투(Ubuntu)등이 대표적인 종류로 볼 수 있습니다. 리눅스의 버전또한 다양한데, 리눅스의 버전은 곧 커널버전을 뜻한다고합니다. 저는 fedora의 하위, 상위버전과 CentOS를 사용해 봤는데, 기본적인 리눅스 명령어는 동일합니다.\n리눅스의 특징  다중 사용자/멀티태스킹을 완벽하게 지원 강력한 네트워킹 기능을 제공 안정적인 운영체제 다양한 플랫폼을 지원 무료 운영체제(일부 배포판 제외) 공개 운영체제 하드웨어 요구사양이 낮음 설치와 설정이 어렵지만, 배포판의 선택으로 어느 정도 극복 가능 현재 서버 및 임베디드 시스템의 운영체제로도 많이 사용되고 있음  리눅스 파일 일반 파일 데이터를 저장하는데 사용되는 파일이다. 이미지 파일, 텍스트 파일, 실행 파일 등 리눅스에서 사용되는 대부분의 파일이 일반에 해당된다. 이미지 파일, 실행 파일, 데이터 파일은 0과1(바이너리)의 형태로 저장되어 바이너리 파일이라고도 불린다. 텍스트 파일의 내용은 아스키(ASCII)코드로 구성되어 문서 편집기를 이용하여 내용을 보거나 수정할 수 있지만, 나머지 파일들은 특정 응용 프로그램이 있어야 한다.\n디렉토리 파일 디렉토리에 속하는 파일의 이름과 inode정보를 가지고 있는 파일이다.\n링크 파일 원본 파일을 대신해서 다른 이름으로 파일명을 지정한 파일이다. 우리가 사용하는 바로가기라고 생각할 수 있다.\n장치 파일 리눅스 시스템의 장치(하드웨어)들을 관리하기 위한 특수 파일이다. 장치를 관리하기 위해서는 이 파일에 접근해야한다.\n리눅스 파일 시스템 위와 같이 계층적으로 구성된 파일과, 디렉토리의 집합을 파일 시스템이라고 부른다. 계층적 구조로 시스템 내의 수많은 파일들을 효율적으로 관리 할 수 있다.\n파일 디렉토리 규칙 \u0026lsquo;/\u0026lsquo;를 이름에 사용할 수 없다. 알파벳, 숫자, 파이픈, 밑줄, 점만 사용한다. 파일과 디렉토리 이름은 대소문자를 구별하며, \u0026lsquo;.\u0026lsquo;으로 시작하는 파일은 숨김 파일로 간주한다.\n최상위 root 디렉토리 \u0026lsquo;/\u0026lsquo;로 표기되며 모든 디렉토리의 상위 디렉토리이다.\n하위 디렉토리(서브 디렉토리) 디렉토리 아래에 위치한 디렉토리이다.\n상위 디렉토리(부모 디렉토리) \u0026lsquo;..\u0026lsquo;으로 표기되며 루트 디렉토리를 제외한 모든 디렉토리는 상위디렉토리가 있다.\n작업 디렉토리(Working Directory) \u0026lsquo;.\u0026lsquo;으로 표기되며 현재 위치한 디렉토리(Current Directory)라고도 불린다.\n홈 디렉토리(Home Directory) \u0026lsquo;~\u0026lsquo;으로 표기되며 사용자에게 할당된 작업영역으로, 다중 사용자 시스템에서 어느 사용자든 홈 디렉토리를 가지고 있다.\n경로 표기법   절대경로 루트 디렉토리부터 시작하여 특정 파일이나 디렉토리의 위치까지 이동하면서 거치는 모든 중간 디렉토리의 이름을 표시한다. 무조건 /로 시작한다. ex) /usr/local/bin\n  상대경로 현재 작업하고 있는 디렉토리에서의 상대적인 위치로 표시하는 방법이다. 현재 작업하고 있는 디렉토리를 \u0026lsquo;.\u0026lsquo;로, 상위 디렉토리를 \u0026lsquo;..\u0026lsquo;로 표시한다. 상대경로는 현재 디렉토리가 어디냐에 따라서 달라진다. 현재 위치가 /usr/local 이라고 보면 상위 디렉토리인 usr는 ..라고 할 수 있고 최상위 디렉토리인 root는 ../..라고 할 수 있다.\n  "
},
{
	"uri": "/basics_of_computer_science/database/database/",
	"title": "Database",
	"tags": ["Database", "Data"],
	"description": "",
	"content": "Database 데이터베이스를 사용하는 이유 데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. (현재도 부분적으로 사용되고 있다.) 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다. 이 때의 문제점은 데이터 종속성 문제와 중복성, 데이터 무결성이다.\n데이터베이스의 특징  데이터의 독립성  물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다. 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.   데이터의 무결성 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다. 데이터의 보안성 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다. 데이터의 일관성 연관된 정보를 논리적은 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다. 데이터 중복 최소화 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.  데이터베이스의 성능? 데이터베이스의 성능 이슈는 디스크 I/O 를 어떻게 줄이느냐에서 시작된다. 디스크 I/O 란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.\n그렇기 때문에 순차 I/O 가 랜덤 I/O 보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분의 I/O 작업이 랜덤 I/O 이다. 랜덤 I/O 를 순차 I/O 로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.\n Reference  https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4 https://coding-factory.tistory.com/77  "
},
{
	"uri": "/roadmap/2020-roadmap-devops/2020-roadmap-devops/",
	"title": "Devops",
	"tags": [],
	"description": "",
	"content": "2020 Roadmap Devops Reference  https://github.com/kamranahmedse/developer-roadmap https://github.com/devJang/developer-roadmap  "
},
{
	"uri": "/basics_of_computer_science/network/dns/",
	"title": "DNS",
	"tags": ["DNS"],
	"description": "",
	"content": "Domain Name System 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발되었습니다.\n특정 컴퓨터(또는 네트워크로 연결된 임의의 장치)의 주소를 찾기 위해, 사람이 이해하기 쉬운 도메인 이름을 숫자로 된 식별 번호(IP 주소)로 변환해 줍니다.\n DNS 구조 DNS는 다음과 같은 Root, Top-Level, Second-Level, Sub의 위계 구조를 갖는다.해당 부분을 담당하는 컴퓨터(DNS 서버)가 각각 존재하며, DNS는 서버는 Root에서 시작해서 Sub로 거슬러 올라가며 IP를 탐색한다.\nDNS 작동방식    Reference  https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%84%A4%EC%9E%84_%EC%8B%9C%EC%8A%A4%ED%85%9C  "
},
{
	"uri": "/example_code/java/",
	"title": "Java Code",
	"tags": [],
	"description": "",
	"content": "Java 예제 코드입니다.\n"
},
{
	"uri": "/basics_of_computer_science/operating_system/process_thread/",
	"title": "Process/Thread",
	"tags": ["Process", "Thread", "PCB", "MultiThread", "MultiProcess", "Scheduling"],
	"description": "",
	"content": "Process 와 Thread 프로세스 / Process 프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것을 말한다.\n운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다.\n구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다.\n또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다.\n프로세스 제어 블록 (Process Control Block, PCB) PCB 는 특정 프로세스에 대한 중요한 정보를 저장 하고 있는 운영체제의 자료구조이다. 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB 를 생성 한다. 프로세스는 CPU 를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU 를 반환해야 하는데, 이때 작업의 진행 상황을 모두 PCB 에 저장하게 된다. 그리고 다시 CPU 를 할당받게 되면 PCB 에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다.\n PCB 에 저장되는 정보  프로세스 식별자(Process ID, PID) : 프로세스 식별번호 프로세스 상태 : new, ready, running, waiting, terminated 등의 상태를 저장 프로그램 카운터 : 프로세스가 다음에 실행할 명령어의 주소 CPU 레지스터 CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록 어카운팅 정보 : 사용된 CPU 시간, 시간제한, 계정번호 등    프로세스 스케줄링 (Process Scheduling) 프로세스를 스케줄링하기 위한 Queue 에는 세 가지 종류가 존재한다.\n Queue Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합 Ready Queue : 현재 메모리 내에 있으면서 CPU 를 잡아서 실행되기를 기다리는 프로세스의 집합 Device Queue : Device I/O 작업을 대기하고 있는 프로세스의 집합  각각의 Queue 에 프로세스들을 넣고 빼주는 스케줄러에도 크게 세 가지 종류가 존재한다.\n Scheduler 장기스케줄러(Long-term scheduler or job scheduler)  메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리(일반적으로 디스크)에 임시로 저장된다. 이 pool 에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리를 할당하여 ready queue 로 보낼지 결정하는 역할을 한다. 메모리와 디스크 사이의 스케줄링을 담당. 프로세스에 Memory(및 각종 리소스)를 할당(Admit) 실행중인 프로세스의 수 제어 프로세스의 상태 :: new -\u0026gt; ready(in memory)   단기스케줄러(Short-term scheduler or CPU scheduler)  CPU 와 메모리 사이의 스케줄링을 담당. Ready Queue 에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정. 프로세스에 CPU 를 할당(scheduler dispatch) 프로세스의 상태 :: ready -\u0026gt; running -\u0026gt; waiting -\u0026gt; ready   중기스케줄러(Medium-term scheduler or Swapper)  여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping) 프로세스에게서 memory 를 deallocate degree of Multiprogramming 제어 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러. 프로세스의 상태 :: ready -\u0026gt; suspended    메모리에 프로그램이 너무 많이 올라가도, 너무 적게 올라가도 성능이 좋지 않은 것이다. 참고로 time sharing system 에서는 장기 스케줄러가 없다. 그냥 곧바로 메모리에 올라가 ready 상태가 된다.\n 스레드 / Thread 스레드는 프로세스의 실행 단위라고 할 수 있다.\n한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.\n스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 스택으로 구성된다.\n같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다.\n하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 한다.\n이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다.\n스택을 스레드마다 독립적으로 할당하는 이유 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것이다.\n따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.\nPC Register 를 스레드마다 독립적으로 할당하는 이유 PC 값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.\n스레드는 CPU 를 할당받았다가 스케줄러에 의해 다시 선점당한다.\n그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당한다.\n 멀티스레드 / Multithread 멀티스레드의 장점 프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우 메모리 공간과 시스템 자원 소모가 줄어들게 된다.\n스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용하여 데이터를 주고받을 수 있다.\n그렇기 때문에 프로세스 간 통신 방법에 비해 스레드 간의 통신 방법이 훨씬 간단하다.\n심지어 스레드의 context switch 는 프로세스 context switch 와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.\n따라서 시스템의 throughtput 이 향상되고 자원 소모가 줄어들며 자연스럽게 프로그램의 응답 시간이 단축된다.\n이러한 장점 때문에 여러 프로세스로 할 수 있는 작업들을 하나의 프로세스에서 스레드로 나눠 수행하는 것이다.\n멀티 스레드의 문제점 멀티 프로세스 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만 멀티 스레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다. 서로 다른 스레드가 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.\n그렇기 때문에 멀티스레딩 환경에서는 동기화 작업이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 병목현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락으로 인한 병목현상을 줄여야 한다.\n 멀티 스레드 (MultiThread) 와 멀티 프로세스 (MultiProcess) 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다.\n반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다.\n이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다.\n따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.\n Reference  https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4 https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85) https://www.geeksforgeeks.org/difference-between-process-and-thread/ https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread https://www.guru99.com/difference-between-multiprocessing-and-multithreading.html  "
},
{
	"uri": "/basics_of_computer_science/design_pattern/restful_api/",
	"title": "Restful Api",
	"tags": ["RestFulApi"],
	"description": "",
	"content": "Restful Api 란 ? REST API(RESTful API, 레스트풀 API)란 REST 아키텍처의 제약 조건을 준수하는 애플리케이션 프로그래밍 인터페이스를 뜻합니다.\nREST는 Representational State Transfer의 줄임말입니다.\nAPI 또는 애플리케이션 프로그래밍 인터페이스(Application Programming Interface)는 애플리케이션 소프트웨어를 구축하고 통합하는 정의 및 프로토콜 세트입니다.\n때때로 API는 정보 제공자와 정보 사용자 간의 계약으로 지칭되며 소비자에게 필요한 콘텐츠(호출)와 생산자에게 필요한 콘텐츠(응답)를 구성합니다.\n즉, 컴퓨터나 시스템과 상호 작용하여 정보를 검색하거나 기능을 수행하고자 할 때 API는 사용자가 원하는 것을 시스템에 전달할 수 있게 지원하여 시스템이 이 요청을 이해하고 이행하도록 할 수 있습니다.\nAPI를 사용자 또는 클라이언트, 그리고 사용자와 클라이언트가 얻으려 하는 리소스 사이의 조정자로 생각하면 됩니다. API는 조직이 보안 및 제어를 유지관리(누가 무엇에 액세스할 수 있는지 결정)하면서 리소스와 정보를 공유할 수 있는 방법이기도 합니다.\nAPI의 또 다른 이점은 리소스 검색 방법 또는 리소스의 출처에 대한 지식 없이도 사용이 가능하다는 점입니다.\nRESTful 이란 ? REST는 프로토콜이나 표준이 아닌 아키텍처 원칙 세트입니다. API 개발자는 REST를 다양한 방식으로 구현할 수 있습니다.\nRESTful API를 통해 요청이 수행될 때 RESTful API는 리소스 상태에 대한 표현을 요청자에게 전송합니다. 이 정보 또는 표현은 HTTP: JSON(Javascript Object Notation), HTML, XLT 또는 일반 텍스트를 통해 몇 가지 형식으로 전송됩니다. JSON은 그 이름에도 불구하고 사용 언어와 상관이 없을 뿐 아니라 인간과 머신이 모두 읽을 수 있기 때문에 가장 널리 사용됩니다.\nAPI가 RESTful로 간주되려면 다음 기준을 따라야 합니다.\n 클라이언트, 서버 및 리소스로 구성되었으며 요청이 HTTP를 통해 관리되는 클라이언트-서버 아키텍처 스테이트리스(stateless) 클라이언트-서버 커뮤니케이션: 요청 간에 클라이언트 정보가 저장되지 않으며, 각 요청이 분리되어 있고 서로 연결되어 있지 않음 클라이언트-서버 상호 작용을 간소화하는 캐시 가능 데이터 정보가 표준 형식으로 전송되도록 하기 위한 구성 요소 간 통합 인터페이스. 여기에 필요한 것은 다음과 같습니다.  요청된 리소스가 식별 가능하며 클라이언트에 전송된 표현과 분리되어야 합니다. 수신한 표현을 통해 클라이언트가 리소스를 조작할 수 있어야 합니다(이렇게 할 수 있는 충분한 정보가 표현에 포함되어 있기 때문). 클라이언트에 반환되는 자기 기술적(self-descriptive) 메시지에 클라이언트가 정보를 어떻게 처리해야 할지 설명하는 정보가 충분히 포함되어야 합니다. 하이퍼미디어: 클라이언트가 리소스에 액세스한 후 하이퍼링크를 사용해 현재 수행 가능한 기타 모든 작업을 찾을 수 있어야 합니다.   요청된 정보를 검색하는 데 관련된 서버(보안, 로드 밸런싱 등을 담당)의 각 유형을 클라이언트가 볼 수 없는 계층 구조로 체계화하는 계층화된 시스템. 코드 온디맨드(선택 사항): 요청을 받으면 서버에서 클라이언트로 실행 가능한 코드를 전송하여 클라이언트 기능을 확장할 수 있는 기능.  이처럼 REST API는 따라야 할 기준이 있지만, 속도를 저하시키고 더 무겁게 만드는 XML 메시징, 빌트인 보안 및 트랜잭션 컴플라이언스처럼 특정 요구 사항이 있는 SOAP(Simple Object Access Protocol) 등의 규정된 프로토콜보다 사용하기 쉬운 것으로 간주됩니다.\n이와 대조적으로 REST는 필요에 따라 구현할 수 있는 일련의 지침으로, 이를 통해 REST API는 더 빨라지고 경량화되며 사물인터넷(IoT) 및 모바일 앱 개발에 가장 적합한 API가 됩니다.\nREST API 디자인 가이드 REST API 설계 시 가장 중요한 항목은 다음의 2가지로 요약할 수 있습니다.\n 첫 번째, URI는 정보의 자원을 표현해야 한다. 두 번째, 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.   REST API 중심 규칙  URI는 정보의 자원을 표현해야 한다. (리소스명은 동사보다는 명사를 사용)  GET /members/delete/1 위와 같은 방식은 REST를 제대로 적용하지 않은 URI입니다. URI는 자원을 표현하는데 중점을 두어야 합니다. delete와 같은 행위에 대한 표현이 들어가서는 안됩니다.\n자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)로 표현 위의 잘못 된 URI를 HTTP Method를 통해 수정해 보면  DELETE /members/1 으로 수정할 수 있겠습니다. 회원정보를 가져올 때는 GET, 회원 추가 시의 행위를 표현하고자 할 때는 POST METHOD를 사용하여 표현합니다.\n회원정보를 가져오는 URI\nGET /members/show/1 (x) GET /members/1 (o) 회원을 추가할 때\nGET /members/insert/2 (x) - GET 메서드는 리소스 생성에 맞지 않습니다. POST /members/2 (o) HTTP METHOD의 알맞은 역할    METHOD 역할     POST POST를 통해 해당 URI를 요청하면 리소스를 생성합니다.   GET GET를 통해 해당 리소스를 조회합니다. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다.   PUT PUT를 통해 해당 리소스를 수정합니다.   DELETE DELETE를 통해 리소스를 삭제합니다.     URI 설계 시 주의할 점  슬래시 구분자(/)는 계층 관계를 나타내는 데 사용  http://restapi.example.com/houses/apartments http://restapi.example.com/animals/mammals/whales URI 마지막 문자로 슬래시(/)를 포함하지 않는다. URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 합니다. REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않습니다.  http://restapi.example.com/houses/apartments/ (X) http://restapi.example.com/houses/apartments (0)  하이픈(-)은 URI 가독성을 높이는데 사용 URI를 쉽게 읽고 해석하기 위해, 불가피하게 긴 URI경로를 사용하게 된다면 하이픈을 사용해 가독성을 높일 수 있습니다.\n  밑줄(_)은 URI에 사용하지 않는다. 글꼴에 따라 다르긴 하지만 밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 합니다. 이런 문제를 피하기 위해 밑줄 대신 하이픈(-)을 사용하는 것이 좋습니다.(가독성)\n  URI 경로에는 소문자가 적합하다. URI 경로에 대문자 사용은 피하도록 해야 합니다. 대소문자에 따라 다른 리소스로 인식하게 되기 때문입니다. RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문이지요.\n  파일 확장자는 URI에 포함시키지 않는다.\n  http://restapi.example.com/members/soccer/345/photo.jpg (X) REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않습니다. Accept header를 사용하도록 합시다.\nGET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg HTTP 응답 상태 코드 잘 설계된 REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것까지 포함되어야 합니다. 정확한 응답의 상태코드만으로도 많은 정보를 전달할 수가 있기 때문에 응답의 상태코드 값을 명확히 돌려주는 것은 생각보다 중요한 일이 될 수도 있습니다. 혹시 200이나 4XX관련 특정 코드 정도만 사용하고 있다면 처리 상태에 대한 좀 더 명확한 상태코드 값을 사용할 수 있기를 권장하는 바입니다.\n참고 : https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C\nReference  https://www.redhat.com/ko/topics/api/what-is-a-rest-api https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C https://meetup.toast.com/posts/92 https://www.redhat.com/ko/topics/integration/whats-the-difference-between-soap-rest  "
},
{
	"uri": "/basics_of_computer_science/common_sense_of_development/",
	"title": "개발상식",
	"tags": [],
	"description": "",
	"content": "개발을 하며 화두로 생각해볼만한 내용입니다.\n \r좋은 코드란 무엇인가?\r\r프로그래밍을 하는 개발자는 모두 좋은 코드를 작성하고 싶다고 생각한다. 누구나 관심 있어 하는 주제인 만큼, 여러 고민을 거듭해왔고 여태까지의 생각을 정리해보려고 한다. 어떤 프로그램을 구성하는 코드냐에 따라 여러 기준으로 생각해보았다. Good Code ? \u0026ldquo;좋은 코드란?\u0026rdquo; 이라고 구글링해보면 많은 검색 결과가 나온다. \u0026ldquo;좋은 코드\u0026quot;란 정체도, 실체도 없이 이 세상에 떠돌고 있다. 모두가 \u0026ldquo;좋은 코드\u0026quot;의 기준이 조금씩 다르고 각각의 경험을 기반으로 좋은 코드를 정의하고 있다. 좋은 코드의 정의는 정말 많다. 읽기 쉬운 코드 중복이 없는 코드 테스트가 용이한 코드 \u0026hellip;.\n\rParadigm\r\rProgramming Paradigm 위키백과에 프로그래밍 패러다임에 대한 내용은 아래와 같다. 프로그래밍 패러다임은 프로그래머에게 프로그래밍의 관점을 갖게 해 주고, 결정하는 역할을 한다. 여기서 알아볼 내용은 아래의 3가지 이다. 명령형 프로그래밍: 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식 절차지향 프로그래밍: 수행되어야 할 연속적인 계산 과정을 포함하는 방식 (C, C++) 객체지향 프로그래밍: 객체들의 집합으로 프로그램의 상호작용을 표현 (C++, Java, C#) 선언형 프로그래밍: 어떤 방법으로 해야 하는지(How)를 나타내기보다 무엇(What)과 같은지를 설명하는 방식 함수형 프로그래밍: 순수 함수를 조합하고 소프트웨어를 만드는 방식 (클로저, 하스켈, 리스프) Procedural Programming 절차지향 프로그래밍\n\rTDD\r\rTDD 란 무엇인가? Test Driven Development(TDD)는 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스이다. 우선 개발자는 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성한다. 일단 테스트 통과하는 코드를 작성하고 상황에 맞게 리팩토링하는 과정을 거치는 것이다. 말 그대로 테스트가 코드 작성을 주도하는 개발방식인 것이다. Add a test 테스트 주도형 개발에선, 새로운 기능을 추가하기 전 테스트를 먼저 작성한다. 테스트를 작성하기 위해서, 개발자는 해당 기능의 요구사항과 명세를 분명히 이해하고 있어야 한다.\n\r"
},
{
	"uri": "/basics_of_computer_science/common_sense_of_development/what_is_good_code/",
	"title": "좋은 코드란 무엇인가?",
	"tags": ["Good Code", "Tips"],
	"description": "",
	"content": "프로그래밍을 하는 개발자는 모두 좋은 코드를 작성하고 싶다고 생각한다.\n누구나 관심 있어 하는 주제인 만큼, 여러 고민을 거듭해왔고 여태까지의 생각을 정리해보려고 한다.\n어떤 프로그램을 구성하는 코드냐에 따라 여러 기준으로 생각해보았다.\n Good Code ? \u0026ldquo;좋은 코드란?\u0026rdquo; 이라고 구글링해보면 많은 검색 결과가 나온다.\n\u0026ldquo;좋은 코드\u0026quot;란 정체도, 실체도 없이 이 세상에 떠돌고 있다.\n모두가 \u0026ldquo;좋은 코드\u0026quot;의 기준이 조금씩 다르고 각각의 경험을 기반으로 좋은 코드를 정의하고 있다.\n좋은 코드의 정의는 정말 많다.\n 읽기 쉬운 코드 중복이 없는 코드 테스트가 용이한 코드 \u0026hellip;.   15년 이상의 경력이 있는 프로그래머 Andrey는 아래와 같이 정의 하고 있습니다.\n1. Optimization VS Readability 코드는 항상 읽기 쉽고 개발자가 이해할수 있는 내용이여야 합니다.\n읽기 어려운 코드에 소요되는 시간과 리소스는 코드를 최적화해서 얻는것보다 훨씬 많습니다.\n최적화가 필요한경우 DI를 사용해서 독립적인 모듈로 만들며, 테스트 커버리지를 유지하여 최소 1년간 수정하지 않도록 만들으세요.\n2. Architecture \u0026ldquo;우리는 빨리 개발을 해야하기 때문에 아키텍처를 설계할 시간이 없다.\u0026quot; 라고 말하는 사람은 대부분 큰 문제가 생깁니다.\n아키텍처 없이 코드를 작성하는것은 쓸모없는 코드를 작성하게 됩니다.\n코드를 작성하기 전에 먼저 수행할 작업, 사용 방법, 모듈화 방법, 서비스간의 의존성, 구조, 테스트 방법 및 디버깅 방법 향후 업데이트 방법을 고려해야합니다.\n3. Test coverage 테스트는 좋지만 항상 효율적인것은 아니며 프로젝트에 따라 다릅니다.\n  테스트가 필요한 경우\n 최소 한 달간은 수정하지 않아도 될 모듈이나 마이크로서비스를 개발하는 경우 오픈소스 코드를 작성하는 경우 핵심 코드 또는 금전적인 부분과 맞닿는 코드를 작성하는 경우 코드를 업데이트 하는 것과 동시에 테스트를 업데이트 할 수 있는 충분한 비용이 있는 경우    테스트가 필요하지 않은 경우\n 스타트업인 경우 팀이 작고 코드가 빠르게 변하는 경우 출력값을 보고 간단하게 수동으로 테스트가 가능한 스크립트를 작성하는 경우    잘못된 테스트 코드와 함께 코드를 짜는 것은 테스트가 없는 코드보다 더 위험할수 있습니다.\n4. Keep It Simple 복잡한 코드를 작성하지 마세요.\n간단하게 작성하면 버그가 줄어들고, 디버깅 시간이 줄어듭니다.\n코드는 추상화 및 객체 지향적인 문제 (특히 Java 기반 개발자) 없이 정확히 필요한 일만을 수행해야 하며, 추후에 간단한 방법으로 업데이트가 가능해야합니다.\n5. Comments 주석은 나쁜 코드를 보여준다. 좋은 코드는 주석 없이도 이해할 수 있어야합니다.\n그러면 새로운 개발자를 위해 시간을 절약하기 위해 해야 할 일은 무엇일까 ?\n메서드의 정의와 사용법을 설명하는 한 줄짜리 간단한 문서를 작성하세요.\n해당 문서는 코드 이해에 필요한 많은 시간을 절약해줄것이며, 더 많은 사람들이 메서드를 잘 이해하고 구현할수 있는 기회를 제공해줍니다.\n이러한 행위는 글로벌 코드 문서화를 위한 좋은 시작점이 됩니다.\n6. Hard coupled VS Less Coupled 항상 마이크로서비스 아키텍처를 사용하도록 노력하세요.\n모놀리틱 소프트웨어는 마이크로서비스 소프트웨어보다 빠르지만, 단일 서버 환경에서만 그렇습니다.\n마이크로서비스는 소프트웨어를 여러 서버로의 분산뿐만 아니라 가끔은 하나의 머신에서의 분산처리(프로세스 분산)도 할 수 있는 가능성을 제공해줍니다.\n7. Code reviews 코드 리뷰는 좋을 수도 있고 나쁠 수도 있습니다.\n팀에 코드의 95%를 이해하고 있고 시간 낭비 없이 모든 업데이트 사항을 모니터링 할 수 있는 개발자가 있는 경우에만 코드 리뷰를 도입하도록 하세요.\n이 외의 경우에는 단지 시간 낭비가 될 수 있으며 모두가 이를 싫어하게 될 것이다.\n많은 사람들은 코드 리뷰가 새로운 사람이나 코드의 다른 부분을 작업하는 팀원을 가르치는 좋은 방법이라고 생각합니다. 그러나 코드 리뷰의 주요 목표는 코드 품질을 유지하는 것이지 가르치는게 아닙니다.\n좋은 팀은 각자가 자신의 역할을 가지고 있으며 일의 한 부분에 대해 완전한 책임감을 갖고 있는 팀입니다.\n만약 누가 코드의 다른 부분을 이해하고 싶으면 해당 부분을 담당하고 있는 사람에게 찾아가 질문을 하면 됩니다.\n모든걸 아는건 불가능하며 전체보다는 코드의 작은 부분을 완전히 이해하는것이 더 좋습니다.\n8. Refactoring does not work 나는 일하는 동안 \u0026ldquo;나중에 리팩토링 할거니까 걱정하지마라\u0026rdquo; 라는 말을 많이 들었습니다.\n그리고 나중에 이는 큰 기술적 부채로 돌아오거나 모든 코드를 다 삭제한 후 처음부터 다시 작성하게 되었습니다.\n따라서 처음부터 여러번 소프트웨어 다시 개발할 수 있는 자금이 있는게 아니라면 기술적 부채를 만들지 마세요.\n9. Don’t write code when you are tired or in a bad mood 개발자들이 피곤할 땐 평소보다 2-5배 더 많은 버그와 실수를 만들어냅니다.\n그렇기 때문에 하루의 업무시간을 약 6시간으로 고려하는 국가가 점점 더 많아지고 있으며, 일부 국가에서는 이미 실천하고있습니다.\n정신적인 일은 육체적인 일을 다루는 것과 같지 않습니다.\n10. Don’t write all at once 코드를 작성하기 전에 우선 여러분의 고객과 클라이언트가 정말로 필요로 하는걸 분석하고 예측하고, 짧은 기간동안 개발할 수 있는 MVF(Most Valuable Features)를 추려내세요.\n품질 업데이트를 배포하기 위해 이러한 반복을 사용하도록 하고 무리한 요구사항과 품질 희생에 시간과 자원을 낭비하지 마세요.\n11. Automation VS manual 자동화는 장기적으로 무조건 좋습니다.\n따라서 지금 당장 무언가를 자동화 할 수 있는것이 있다면 바로 하세요.\n\u0026ldquo;5 분 밖에 걸리지 않는데, 왜 자동화 해야해?\u0026rdquo; 라고 생각할 수도 있다.\n하지만 한 번 계산해보자.\n예를 들어 5명의 개발자로 이루어진 팀의 일상적인 작업을 들어보자.\n5분 * 5명 * 21일 * 12개월 = 6,300분 = 105시간 = 13.125 일 ~ 5,250$.\n직원이 40,000명일 경우엔 비용이 얼마나 커질까?\n12. Go out, get hobbies 일의 차별화는 정신 능력을 향상시키며 새롭고 신선한 아이디어를 제공합니다.\n따라서 잠시 쉬고 신선한 공기를 마시거나 친구들과 이야기를 하거나 기타를 연주하는등의 취미를 가지세요.\n13. Learn new things as you get free time 배우는것을 멈추게되면 퇴화가 시작됩니다.\n Reference  https://hackernoon.com/few-simple-rules-for-good-coding-my-15-years-experience-96cb29d4acd9  "
},
{
	"uri": "/java/annotation/",
	"title": "Annotation",
	"tags": [],
	"description": "",
	"content": "Annotation 어노테이션이란 본래 주석이란 뜻으로, 인터페이스를 기반으로 한 문법이다.\n주석과는 그 역할이 다르지만 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다.\n또 해석되는 시점을 정할 수도 있다.(Retention Policy)\n어노테이션에는 크게 세 가지 종류가 존재한다.\nJDK 에 내장되어 있는 built-in annotation과 어노테이션에 대한 정보를 나타내기 위한 어노테이션인 Meta annotation 그리고 개발자가 직접 만들어 내는 Custom Annotation이 있다.\nbuilt-in annotation 은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 어노테이션이 그 대표적인 예이다.\n어노테이션의 동작 대상을 결정하는 Meta-Annotation 에도 여러 가지가 존재한다.\n"
},
{
	"uri": "/roadmap/2020-roadmap-backend/2020-roadmap-backend/",
	"title": "Backend",
	"tags": [],
	"description": "",
	"content": "2020 Roadmap Backend Reference  https://github.com/kamranahmedse/developer-roadmap https://github.com/devJang/developer-roadmap  "
},
{
	"uri": "/ci_cd/cd/",
	"title": "CD",
	"tags": [],
	"description": "",
	"content": "CD(Continuous Delivery / Deployment) - 지속적 전달 / 배포 CI가 빌드 및 테스트 자동화라면 CD는 배포 자동화 에 대한 개념이다.\nCD는 자동화의 수준에 따라 아래 2가지로 구별할 수 있다.\n Continuous Delivery Continuous Deployment  이 둘의 차이점은 \u0026lsquo;프로덕션 배포까지 자동화하는가\u0026rsquo; 다.\nContinuous Delivery (지속적 전달)은 프로덕션은 수동 으로 배포한다. Continuous Deployment (지속적 배포)는 프로덕션까지 자동으로 배포 한다.\nCD 예시\n CI 예시에서 CI가 정상적으로 수행되고 나면 빌드된 파일을 CD에 전달한다. CD에서는 빌드가 완료된 파일을 받아서 전처리 / 후처리 등을 수행한다. 아래에선 2가지 예시를 간단하게 설명한다.  기존에 동작하던 애플리케이션을 종료시키고 업데이트된 빌드 파일로 애플리케이션을 구동 무중단 배포의 경우, 새로 업데이트된 파일을 다른 포트에 풀어놓고, 구동이 완료되면 프락시에서 들어오는 요청을 스위칭 함 (reverse proxy)    "
},
{
	"uri": "/basics_of_computer_science/database/index/",
	"title": "Index",
	"tags": ["Index"],
	"description": "",
	"content": "Index 인덱스(Index)란 무엇인가? 인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인이라고 할 수 있다. 이 비유를 그대로 가져와서 인덱스를 살펴본다면 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 될 것이다. DBMS 도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.\nDBMS 의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 결론적으로 DBMS 에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.\nIndex 자료구조 B+-Tree 인덱스 알고리즘 일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다. B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리한다.), 원래의 값을 이용해 인덱싱하는 알고리즘이다.\nHash 인덱스 알고리즘 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 데이터베이스에서 많이 사용한다.\n왜 index 를 생성하는데 b-tree 를 사용하는가? 데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같지만 SELECT 질의의 조건에는 부등호(\u0026lt;\u0026gt;) 연산도 포함이 된다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않다.\nPrimary Index vs Secondary Index 클러스터(Cluster)란 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 클러스터드 인덱스도 크게 다르지 않다. 인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것이다. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말한다.\n클러스터드 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터드 인덱스라고 표현한다. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다. 그렇기 때문에 프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야 한다.\n클러스터드 인덱스는 테이블 당 한 개만 생성할 수 있다. 프라이머리 키에 대해서만 적용되기 때문이다, 이에 반해 non 클러스터드 인덱스는 테이블 당 여러 개를 생성할 수 있다.\nComposite Index 인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title 을 search 하는 경우, index 를 생성한 효과를 볼 수 있지만, author 만으로 search 하는 경우, index 를 생성한 것이 소용이 없어진다. 따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.\n Index 의 성능과 고려해야할 사항 SELECT 쿼리의 성능을 월등히 향상시키는 INDEX 항상 좋은 것일까? 쿼리문의 성능을 향상시킨다는데, 모든 컬럼에 INDEX 를 생성해두면 빨라지지 않을까? 결론부터 말하자면 그렇지 않다. 우선, 첫번째 이유는 INDEX 를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다. INSERT 의 경우 INDEX 에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따른다. DELETE 의 경우 INDEX 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 된다. 즉 row 의 수는 그대로인 것이다. 이 작업이 반복되면 어떻게 될까?\n실제 데이터는 10 만건인데 데이터가 100 만건 있는 결과를 낳을 수도 있는 것이다. 이렇게 되면 인덱스는 더 이상 제 역할을 못하게 되는 것이다. UPDATE 의 경우는 INSERT 의 경우, DELETE 의 경우의 문제점을 동시에 수반한다. 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문이다. 즉 변경 전 데이터는 삭제되지 않고 insert 로 인한 split 도 발생하게 된다.\n하지만 더 중요한 것은 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것이다. 즉, 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적은 데이터의 형식이 존재한다는 것이다. 어떤 경우에 그럴까?\n이름, 나이, 성별 세 가지의 필드를 갖고 있는 테이블을 생각해보자. 이름은 온갖 경우의 수가 존재할 것이며 나이는 INT 타입을 갖을 것이고, 성별은 남, 녀 두 가지 경우에 대해서만 데이터가 존재할 것임을 쉽게 예측할 수 있다. 이 경우 어떤 컬럼에 대해서 인덱스를 생성하는 것이 효율적일까? 결론부터 말하자면 이름에 대해서만 인덱스를 생성하면 효율적이다.\n왜 성별이나 나이는 인덱스를 생성하면 비효율적일까? 10000 레코드에 해당하는 테이블에 대해서 2000 단위로 성별에 인덱스를 생성했다고 가정하자. 값의 range 가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O 가 발생하기 때문에 그 만큼 비효율적인 것이다.\n Reference  https://mangkyu.tistory.com/96 https://itholic.github.io/database-index/ https://itrainbowm.tistory.com/20  "
},
{
	"uri": "/basics_of_computer_science/design_pattern/mvc/",
	"title": "MVC",
	"tags": ["MVC"],
	"description": "",
	"content": "MVC 아키텍쳐에 대한 이해 MVC의 각 컴포넌트의 역할   Controller(컨트롤러)\n 클라이언트의 요청을 받았을 때, 그 요청에 대해 실제 업무를 수행하는 모델 컴포넌트를 호출한다. 또한 클라이언트가 보낸 데이터가 있다면, 모델에 전달하기 쉽게 데이터를 가공한다. 모델이 업무를 마치면 그 결과를 뷰에게 전달한다.    Model (모델)\n 컨트롤러가 호출할 때, 요청에 맞는 역할을 수행한다. 비즈니스 로직을 구현하는 영역으로 응용프로그램에서 데이터를 처리하는 부분이다 비즈니스 로직이란 업무에 필요한 데이터처리를 수행하는 응용프로그램의 일부라고 할 수 있다. DB에 연결하고 데이터를 추출하거나 저장,삭제,업데이트,변환 등의 작업을 수행한다. 상태의 변화가 있을 때 컨트롤러와 뷰에 통보해 후속 조치 명령을 받을 수 있게 한다.    View (뷰)\n 컨트롤러로부터 받은 모델의 결과값을 가지고 사용자에게 출력할 화면을 만드는 일을 한다. 만들어진 화면을 웹브라우저에 전송하여 웹브라우저가 출력하게 하는 것이다. 화면에 표시되는 부분으로 추출한 데이터나 일반적인 텍스트 데이터를 표시하거나 입력폼 또는 사용자와의 상호작용을 위한 인터페이스를 표시하는 영역이다.     MVC 구동 원리  C/S(Client - Server)구조로 요청을 하면 그에 맞는 응답을 하는 구조를 기본으로 하고 있다.\n 웹 브라우저가 웹 서버에 웹 애플리케이션 실행을 요청한다. (MVC 구조가 WAS라고 보면 된다.) 웹 서버는 들어온 요청을 처리할 수 있는 서블릿을 찾아서 요청을 전달한다.(Matching) 서블릿은 모델 자바 객체의 메서드를 호출한다. 데이터를 가공하여 값 객체를 생성하거나 , JDBC를 사용하여 데이터베이스와의 인터랙션을 통해 값 객체를 생성한다. 업무 수행을 마친 결과값을 컨트롤러에게 반환한다. 컨트롤러는 모델로부터 받은 결과값을 View에게 전달한다. JSP는 전달받은 값을 참조하여 출력할 결과 화면을 만들고 컨트롤러에게 전달한다. 뷰로부터 받은 화면을 웹 서버에게 전달한다. 웹 브라우저는 웹 서버로부터 요청한 결과값을 응답받으면 그 값을 화면에 출력한다.  "
},
{
	"uri": "/basics_of_computer_science/common_sense_of_development/paradigm/",
	"title": "Paradigm",
	"tags": ["Paradigm", "PP", "OOP", "FP"],
	"description": "",
	"content": "Programming Paradigm 위키백과에 프로그래밍 패러다임에 대한 내용은 아래와 같다.\n 프로그래밍 패러다임은 프로그래머에게 프로그래밍의 관점을 갖게 해 주고, 결정하는 역할을 한다.\n 여기서 알아볼 내용은 아래의 3가지 이다.\n 명령형 프로그래밍: 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식  절차지향 프로그래밍: 수행되어야 할 연속적인 계산 과정을 포함하는 방식 (C, C++) 객체지향 프로그래밍: 객체들의 집합으로 프로그램의 상호작용을 표현 (C++, Java, C#)   선언형 프로그래밍: 어떤 방법으로 해야 하는지(How)를 나타내기보다 무엇(What)과 같은지를 설명하는 방식  함수형 프로그래밍: 순수 함수를 조합하고 소프트웨어를 만드는 방식 (클로저, 하스켈, 리스프)    Procedural Programming 절차지향 프로그래밍\n프로그램을 피라미드와 같은 구조로 만들고 탑-다운(Top-Down)의 형태로 제어하도록 되어 있습니다.\n구조를 이루는 각각의 단위는 순차, 제어(if,select문 등), 반복(for, while 등)의 세 구조로 이루어져 있습니다.\n구조의 흐름은 순차적이며 작업의 흐름과 코딩 순서가 일치하므로, 논리 흐름을 쉽게 이해할수 있습니다.\nObject Oriented Programming 객체 지향 프로그래밍\n객체란 말 그대로 대상을 나타내는 단어로, 각각의 대상을 객체화 시켜서 객체의 관점에서 프로그래밍 하는것을 말합니다.\nOOP 특징  캡슐화 / Encapsulation  캡슐화란 하나의 객체가 특정한 목적을 달성하기 위해 변수, 함수를 하나로 묶는 것을 의미합니다. 캡슐화의 이점으로 함수를 통한 데이터 접근이 가능하며, 데이터 은닉이 가능합니다.   추상화 / Abstraction  객체에서 공통된 속성과 행위를 추출하는 것을 의미합니다.   다형성 / Polymorphism  다형성은 상속을 받은 기능을 변경하거나 확장하는 것을 의미합니다. 오버 라이딩(OverRiding) : 상위 클래스가 가지고 있는 메소드를 하위 클래스에서 재정의하는것. 오버 로딩(OverLoding) : 이름을 가진 메소드를 매개변수(arguments)를 다르게하여 여러개 사용하는것.   상속성 / Inheritance  상위의 부모 객체(개념)의 속성을 하위 객체(개념)가 물려 받는 것을 의미합니다.    객체 지향적 설계 원칙  SRP(Single Responsibility Principle) : 단일 책임 원칙  클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.   OCP(Open-Closed Principle) : 개방-폐쇄 원칙  확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.   LSP(Liskov Substitution Principle) : 리스코프 치환 원칙  상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.   ISP(Interface Segregation Principle) : 인터페이스 분리 원칙  인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.   DIP(Dependency Inversion Principle) : 의존 역전 원칙  고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.    Functional Programming 함수형 프로그래밍\n함수형 프로그래밍은 계산을 수학적 함수의 조합으로 생각하는 방식을 말한다.\n이것은 일반적인 프로그래밍 언어에서 함수가 특정 동작을 수행하는 역할을 담당하는 것과는 반대되는 개념으로, 함수를 수행해도 함수 외부의 값이 변경될 수 없다.\n함수형 프로그래밍에 필요한 개념   1급 객체 (First Object)\n 변수나 데이터 구조안에 담을 수 있다. 파라미터로 전달 할 수 있다. 반환값(return value)으로 사용할 수 있다. 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다. 동적으로 프로퍼티 할당이 가능하다.    고차 함수 (High-Order Function)\n 람다 계산법에서 만들어진 용어로 아래 조건을 만족하는 함수 함수에 함수를 파라미터로 전달할 수 있다. 함수의 반환값으로 함수를 사용할 수 있다.    불변성 (Immutablility)\n 함수형 프로그래밍에서는 데이터가 변할 수 없는데, 이를 불변성 데이터라고 한다. 데이터 변경이 필요한 경우, 원본 데이터 구조를 변경하지 않고 그 데이터를 복사본을 만들어 그 일부를 변경하고, 변경한 복사본을 사용해 작업을 진행한다.    순수 함수 (Pure function)\n 순수 함수란 함수형 프로그래밍에 필요한 개념으로 아래 조건을 만족하는 함수를 뜻한다. 동일한 입력에는 항상 같은 값을 반환해야 한다. 함수의 실행은 프로그램의 실행에 영향을 미치지 않아야 한다.    데이터 변환방법\n 함수형 프로그래밍은 데이터 변경이 불가능하기 때문에 기존 데이터의 복사본을 만들어 주는 도구들이 필요하다.    합성 함수 (Function composition)\n 합성 함수란 새로운 함수를 만들어거나 계산하기 위해 둘 이상의 함수를 조합하는 과정을 말한다. 함수형 프로그램은 여러 작은 순수 함수들로 이루어져있기 때문에 이 함수들을 연쇄적으로 또는 병렬로 호출해서 더 큰 함수를 만드는 과정으로 전체 프로그램을 구축해야 한다.     Reference  https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84 https://velog.io/@kyusung/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EC%95%BD  "
},
{
	"uri": "/basics_of_computer_science/operating_system/sync_async/",
	"title": "Sync/Async",
	"tags": ["Sync", "Async", "Blocking", "Non-blocking"],
	"description": "",
	"content": "Sync 와 Async 먼저 Synchronous와 Asynchronous의 어원을 확인해보면 Synchronous의 Syn는 together이란 뜻이고, chrono는 time이다.\n따라서 Synchronous는 함께 시간을 맞춘다라는 뜻으로 해석된다.\n반면에 Asynchronous는 앞에 A라는 접두사가 붙어 부정하는 형태가 되어 시간을 맞추지 않는 것이라 해석할 수 있다.\nSync와 Async를 다루려면 위 어원에서 볼 수 있듯이 함께 하는 대상이 누구인지, 그 대상들의 시간은 어떻게 다루어지는지 두 가지를 살펴봐야한다.\n동기 / Synchronous 동기는 두 가지 이상의 대상(함수, 애플리케이션 등)이 서로 시간을 맞춰 행동하는 것이다.\n예를들어 호출한 함수가 호출된 함수의 작업이 끝나서 결과값을 반화하기를 기다리거나, 지속적으로 호출된 함수에게 확인 요청을하는 경우가 있다.\n비동기 / Asynchronous 비동기는 동기와 반대로 대상이 서로 시간을 맞추지 않는 것을 말한다.\n예를 들어 호출하는 함수가 호출되는 함수에게 작업을 맡겨놓고 신경을 쓰지 않는 것을 말한다.\n Blocking / Non-blocking 블록킹/논블록킹을 동기/비동기와 같이 생각하는 경우가 많은데, 이는 서로 관점이 다르다.\n블록킹/논블록킹은 직접 제어할 수 없는 대상을 처리하는 방법에 따라 나눈다.\n직접 제어할 수 없는 대상은 대표적으로 IO, 멀티쓰레드 동기화가 있다.\n블록킹 / Blocking Blocking은 직접 제어할 수 없는 대상의 작업이 끝날 때까지 제어권을 넘겨주지 않는 것이다.\n예를 들어 호출하는 함수가 IO를 요청했을 때 IO처리가 완료될 때까지 아무 일도 하지 못한 채 기다리는 것을 말한다.\n논 블록킹 / Non-blocking Non-Blocking은 Blocking과 반대되는 개념이다.\n직접 제어할 수 없는 대상의 작업 처리 여부와 상관이 없다.\n예를 들어 호출하는 함수가 IO를 요청한 후 IO처리 완료 여부와 상관없이 바로 자신의 작업을 할 수 있다.\n    ⭐ 블록킹 논블록킹     동기 읽기/쓰기 읽기/쓰기 O_NONBLOCK 등 ..   비동기 다중 I/O Select, Poll 등 .. AIO     Reference  https://velog.io/@codemcd/Sync-VS-Async-Blocking-VS-Non-Blocking-sak6d01fhx https://okky.kr/article/442803  "
},
{
	"uri": "/basics_of_computer_science/network/tcp_udp/",
	"title": "TCP/UDP",
	"tags": ["TCP", "UDP"],
	"description": "",
	"content": "TCP 와 UDP UDP / User Datagram Protocol UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)는 비연결형 프로토콜 이다.\nIP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다.\nUDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다.\n이 모두가 사용자 프로세스의 몫이다.\nUDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.\n종종 클라이언트는 서버로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면, 클라이언트는 time out 되고 다시 시도할 수 있으면 된다. 코드가 간단할 뿐만 아니라 TCP 처럼 초기설정(initial setup)에서 요구되는 프로토콜보다 적은 메시지가 요구된다.\nUDP를 사용한 것들에는 DNS가 있다. 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은, DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다.\nTCP / Transmission Control Protocol 대부분의 인터넷 응용 분야들은 신뢰성 과 순차적인 전달 을 필요로 한다.\nUDP 로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 TCP이다.\nTCP(Transmission Control Protocol, 전송제어 프로토콜)는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송 하도록 특별히 설계되었다.\nTCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다.\nTCP 에서 연결 설정(connection establishment)는 3-way handshake를 통해 행해진다.\n모든 TCP 연결은 전이중(full-duplex), 점대점(point to point)방식이다. 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 점대점이란 각 연결이 정확히 2 개의 종단점을 가지고 있음을 의미한다. TCP 는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.\n Reference  http://d2.naver.com/helloworld/47667 https://asfirstalways.tistory.com/356  "
},
{
	"uri": "/basics_of_computer_science/network/",
	"title": "네트워크",
	"tags": [],
	"description": "",
	"content": "네트워크에 관련된 내용입니다.\n \rDNS\r\rDomain Name System 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발되었습니다. 특정 컴퓨터(또는 네트워크로 연결된 임의의 장치)의 주소를 찾기 위해, 사람이 이해하기 쉬운 도메인 이름을 숫자로 된 식별 번호(IP 주소)로 변환해 줍니다. DNS 구조 DNS는 다음과 같은 Root, Top-Level, Second-Level, Sub의 위계 구조를 갖는다.해당 부분을 담당하는 컴퓨터(DNS 서버)가 각각 존재하며, DNS는 서버는 Root에서 시작해서 Sub로 거슬러 올라가며 IP를 탐색한다. DNS 작동방식 Reference https://ko.\n\rTCP/UDP\r\rTCP 와 UDP UDP / User Datagram Protocol UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)는 비연결형 프로토콜 이다. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다. 종종 클라이언트는 서버로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면, 클라이언트는 time out 되고 다시 시도할 수 있으면 된다.\n\rHTTP/HTTPS\r\rHTTP 와 HTTPS HTTP 의 문제점 HTTP 는 평문 통신이기 때문에 도청이 가능하다. 통신 상대를 확인하지 않기 때문에 위장이 가능하다. 완전성을 증명할 수 없기 때문에 변조가 가능하다. 위 세 가지는 다른 암호화하지 않은 프로토콜에도 공통되는 문제점들이다. TCP/IP 는 도청 가능한 네트워크 TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.\n\rHTTP Methods\r\rHTTP Methods HTTP는 요청 메서드를 정의하여, 주어진 리소스에 수행하길 원하는 행동을 나타냅니다. 간혹 요청 메서드를 \u0026ldquo;HTTP 동사\u0026quot;라고 부르기도 합니다. 각각의 메서드는 서로 다른 의미를 구현하지만, 일부 기능은 메서드 집합 간에 서로 공유하기도 합니다. 이를테면 응답 메서드는 안전하거나, 캐시 가능하거나, 멱등성을 가질 수 있습니다. GET GET 메서드는 특정 리소스의 표시를 요청합니다. GET을 사용하는 요청은 오직 데이터를 받기만 합니다. Syntax : GET /index.html HEAD HEAD 메서드는 GET 메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않습니다.\n\r"
},
{
	"uri": "/roadmap/2020-roadmap-frontend/2020-roadmap-frontend/",
	"title": "Frontend",
	"tags": [],
	"description": "",
	"content": "2020 Roadmap Frontend Reference  https://github.com/kamranahmedse/developer-roadmap https://github.com/devJang/developer-roadmap  "
},
{
	"uri": "/java/generic/",
	"title": "Generic",
	"tags": [],
	"description": "",
	"content": "Generic 제네릭은 자바에서 안정성을 맡고 있다고 할 수 있다.\n다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능이다.\n객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움을 줄여준다.\n자연스럽게 코드도 더 간결해진다.\n예를 들면, Collection 에 특정 객체만 추가될 수 있도록, 또는 특정한 클래스의 특징을 갖고 있는 경우에만 추가될 수 있도록 하는 것이 제네릭이다.\n이로 인한 장점은 collection 내부에서 들어온 값이 내가 원하는 값인지 별도의 로직처리를 구현할 필요가 없어진다.\n또한 api 를 설계하는데 있어서 보다 명확한 의사전달이 가능해진다.\n"
},
{
	"uri": "/basics_of_computer_science/network/http_https/",
	"title": "HTTP/HTTPS",
	"tags": ["HTTP", "HTTPS", "TCP", "IP"],
	"description": "",
	"content": "HTTP 와 HTTPS HTTP 의 문제점  HTTP 는 평문 통신이기 때문에 도청이 가능하다. 통신 상대를 확인하지 않기 때문에 위장이 가능하다. 완전성을 증명할 수 없기 때문에 변조가 가능하다.  위 세 가지는 다른 암호화하지 않은 프로토콜에도 공통되는 문제점들이다.\nTCP/IP 는 도청 가능한 네트워크 TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.\n보안 방법  통신 자체를 암호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP 의 통신 내용을 암호화할 수 있다. SSL 을 조합한 HTTP 를 HTTPS(HTTP Secure) or HTTP over SSL이라고 부른다. 콘텐츠를 암호화 말 그대로 HTTP 를 사용해서 운반하는 내용인, HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.  통신 상대를 확인하지 않기 때문에 위장이 가능 HTTP 에 의한 통신에는 상대가 누구인지 확인하는 처리는 없기 때문에 누구든지 리퀘스트를 보낼 수 있다. IP 주소나 포트 등에서 그 웹 서버에 액세스 제한이 없는 경우 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다. 이러한 특징은 여러 문제점을 유발한다.\n 리퀘스트를 보낸 곳의 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인할 수 없다. 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다. 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다. 어디에서 누가 리퀘스트 했는지 확인할 수 없다. 의미없는 리퀘스트도 수신한다. —\u0026gt; DoS 공격을 방지할 수 없다.  보완 방법 위 암호화 방법으로 언급된 SSL로 상대를 확인할 수 있다. SSL 은 상대를 확인하는 수단으로 증명서 를 제공하고 있다. 증명서는 신뢰할 수 있는 제 3 자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 한 가지 이점을 더 꼽자면 클라이언트는 이 증명서로 본인 확인을 하고 웹 사이트 인증에서도 이용할 수 있다.\n완전성을 증명할 수 없기 때문에 변조가 가능 여기서 완전성이란 정보의 정확성 을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 의해 변조되더라도 이 사실을 알 수 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Man-in-the-Middle)이라고 부른다.\n보완 방법 MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 HTTPS를 사용해야 한다. SSL 에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.\n HTTPS  HTTP 에 암호화와 인증, 그리고 완전성 보호를 더한 HTTPS\n HTTPS는 SSL 의 껍질을 덮어쓴 HTTP 라고 할 수 있다. 즉, HTTPS 는 새로운 애플리케이션 계층의 프로토콜이 아니라는 것이다. HTTP 통신하는 소켓 부분을 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 프로토콜로 대체하는 것 뿐이다. HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 SSL 과 통신하고 SSL 이 TCP 와 통신 하게 된다. SSL 을 사용한 HTTPS 는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.\nHTTPS 의 SSL 에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용한다. 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식이다.\n Reference  https://ko.wikipedia.org/wiki/HTTPS https://ko.wikipedia.org/wiki/HTTP  "
},
{
	"uri": "/basics_of_computer_science/operating_system/memory/",
	"title": "Memory",
	"tags": ["Memory", "Paging", "Segmentation", "Virtual Memory"],
	"description": "",
	"content": "Memory 각각의 프로세스 는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.\nSwapping : 메모리의 관리를 위해 사용되는 기법. 표준 Swapping 방식으로는 round-robin 과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다.\n 이 과정을 swap (스왑시킨다) 이라 한다. 주 기억장치(RAM)으로 불러오는 과정을 swap-in, 보조 기억장치로 내보내는 과정을 swap-out 이라 한다. swap 에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할때 Swapping 이 시작된다.\n 단편화 (Fragmentation) : 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 단편화 이다. 단편화는 2 가지 종류로 나뉜다.\n   \u0026lt;- Process A -\u0026gt; \u0026lt;- free -\u0026gt; \u0026lt;- Process B -\u0026gt; \u0026lt;- free -\u0026gt; \u0026lt;- Process C -\u0026gt; \u0026lt;- free -\u0026gt; \u0026lt;- Process D -\u0026gt;     외부 단편화: 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을때 발생한다고 볼 수 있다. 내부 단편화: 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 메모리 분할 자유 공간이 10,000B 있고 Process A 가 9,998B 사용하게되면 2B 라는 차이 가 존재하고, 이 현상을 내부 단편화라 칭한다.  압축 : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다.\n(위의 메모리 현황이 압축을 통해 아래의 그림 처럼 바뀌는 효과를 가질 수 있다)\n   \u0026lt;- Process A -\u0026gt; \u0026lt;- Process B -\u0026gt; \u0026lt;- Process C -\u0026gt; \u0026lt;- Process D -\u0026gt; \u0026lt;- free -\u0026gt;    페이징 / Paging 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.(페이지 교체 알고리즘에 들어가는 페이지)\n페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점이 있다.\n하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping 되어 저장된다고 볼 수 있다.\n 단점 : 내부 단편화 문제의 비중이 늘어나게 된다. 예를들어 페이지 크기가 1,024B 이고 프로세스 A 가 3,172B 의 메모리를 요구한다면 3 개의 페이지 프레임(1,024 * 3 = 3,072) 하고도 100B 가 남기때문에 총 4 개의 페이지 프레임이 필요한 것이다. 결론적으로 4 번째 페이지 프레임에는 924B(1,024 - 100)의 여유 공간이 남게 되는 내부 단편화 문제가 발생하는 것이다.  세그멘테이션 / Segmentation 페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위) 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장\n 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)   Virtual Memory 다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법 이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.\n가상 메모리 개발 배경 실행되는 코드의 전부를 물리 메모리에 존재시켜야 했고, 메모리 용량보다 큰 프로그램은 실행시킬 수 없었다. 또한, 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와, 페이지 교체등의 성능 이슈가 발생하게 된다. 또한, 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점에서, 불필요하게 전체의 프로그램이 메모리에 올라와 있어야 하는게 아니라는 것을 알 수 있다.\n프로그램의 일부분만 메모리에 올릴 수 있다면\u0026hellip;  물리 메모리 크기에 제약받지 않게 된다. 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 응답시간은 유지되고, CPU 이용률과 처리율은 높아진다. swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.  가상 메모리가 하는 일 가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다. 이로써 작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있다.\n가상 주소 공간  한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다. 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로서 현재 직접적으로 필요치 않은 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다. 예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간(Heap영역, Stack 영역, 코드, 데이터)의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.     \u0026lt;- Stack -\u0026gt; \u0026lt;- Free(60KB) -\u0026gt; \u0026lt;- Heap -\u0026gt; \u0026lt;- Data -\u0026gt; \u0026lt;- Code -\u0026gt;     Reference  http://web.mit.edu/rhel-doc/4/RH-DOCS/rhel-isa-ko-4/s1-memory-concepts.html https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A9%94%EB%AA%A8%EB%A6%AC https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B4%80%EB%A6%AC  "
},
{
	"uri": "/basics_of_computer_science/common_sense_of_development/tdd/",
	"title": "TDD",
	"tags": ["TDD"],
	"description": "",
	"content": "TDD 란 무엇인가? Test Driven Development(TDD)는 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스이다.\n우선 개발자는 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성한다.\n일단 테스트 통과하는 코드를 작성하고 상황에 맞게 리팩토링하는 과정을 거치는 것이다.\n말 그대로 테스트가 코드 작성을 주도하는 개발방식인 것이다.\nAdd a test 테스트 주도형 개발에선, 새로운 기능을 추가하기 전 테스트를 먼저 작성한다.\n테스트를 작성하기 위해서, 개발자는 해당 기능의 요구사항과 명세를 분명히 이해하고 있어야 한다.\n이는 사용자 케이스와 사용자 스토리 등으로 이해할 수 있으며, 이는 개발자가 코드를 작성하기 전에 보다 요구사항에 집중할 수 있도록 도와준다.\n이는 정말 중요한 부분이자 테스트 주도 개발이 주는 이점이라고 볼 수 있다.\nRun all tests and see if new one fails 어떤 새로운 기능을 추가하면 잘 작동하던 기능이 제대로 작동하지 않는 경우가 발생할 수 있다.\n더 위험한 경우는 개발자가 이를 미처 인지하지 못하는 경우이다.\n이러한 경우를 방지하기 위해 테스트 코드를 작성하는 것이다.\n새로운 기능을 추가할 때 테스트 코드를 작성함으로써, 새로운 기능이 제대로 작동함과 동시에 기존의 기능들이 잘 작동하는지 테스트를 통해 확인할 수 있는 것이다.\nRefactor code 코드량이 방대해지면서 리팩토링을 하게 된다.\n이 때 테스트 주도 개발을 통해 개발을 해왔다면, 테스트 코드가 그 중심을 잡아줄 수 있다.\n뚱뚱해진 함수를 여러 함수로 나누는 과정에서 해당 기능이 오작동을 일으킬 수 있지만 간단히 테스트를 돌려봄으로써 이에 대한 안심을 하고 계속해서 리팩토링을 진행할 수 있다.\n결과적으로 리팩토링 속도도 빨라지고 코드의 퀄리티도 그만큼 향상하게 되는 것이다.\n코드 퀄리티 부분을 조금 상세히 들어가보면, 보다 객체지향적이고 확장 가능이 용이한 코드, 재설계의 시간을 단축시킬 수 있는 코드, 디버깅 시간이 단축되는 코드가 TDD 와 함께 탄생하는 것이다.\n Reference  https://www.slipp.net/questions/16  "
},
{
	"uri": "/basics_of_computer_science/operating_system/",
	"title": "운영체제",
	"tags": [],
	"description": "",
	"content": "운영체제에 관련된 내용입니다.\n \rProcess/Thread\r\rProcess 와 Thread 프로세스 / Process 프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU 의 할당을 받을 수 있는 것을 말한다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다. 구체적으로 살펴보면 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함한다. 또한 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함한다. 프로세스 제어 블록 (Process Control Block, PCB) PCB 는 특정 프로세스에 대한 중요한 정보를 저장 하고 있는 운영체제의 자료구조이다.\n\rSync/Async\r\rSync 와 Async 먼저 Synchronous와 Asynchronous의 어원을 확인해보면 Synchronous의 Syn는 together이란 뜻이고, chrono는 time이다. 따라서 Synchronous는 함께 시간을 맞춘다라는 뜻으로 해석된다. 반면에 Asynchronous는 앞에 A라는 접두사가 붙어 부정하는 형태가 되어 시간을 맞추지 않는 것이라 해석할 수 있다. Sync와 Async를 다루려면 위 어원에서 볼 수 있듯이 함께 하는 대상이 누구인지, 그 대상들의 시간은 어떻게 다루어지는지 두 가지를 살펴봐야한다. 동기 / Synchronous 동기는 두 가지 이상의 대상(함수, 애플리케이션 등)이 서로 시간을 맞춰 행동하는 것이다.\n\rMemory\r\rMemory 각각의 프로세스 는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, 운영체제 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다. Swapping : 메모리의 관리를 위해 사용되는 기법. 표준 Swapping 방식으로는 round-robin 과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다. 이 과정을 swap (스왑시킨다) 이라 한다.\n\rCache\r\rCache 캐시 메모리는 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다. 이러한 역할을 수행하기 위해서는 CPU 가 어떤 데이터를 원할 것인가를 어느 정도 예측할 수 있어야 한다. 캐시의 성능은 작은 용량의 캐시 메모리에 CPU 가 이후에 참조할, 쓸모 있는 정보가 어느 정도 들어있느냐에 따라 좌우되기 때문이다. 이 때 적중율(Hit rate) 을 극대화 시키기 위해 데이터 지역성(Locality) 의 원리를 사용한다. 지역성의 전제조건으로 프로그램은 모든 코드나 데이터를 균등하게 Access 하지 않는다는 특성을 기본으로 한다.\n\r"
},
{
	"uri": "/basics_of_computer_science/database/normalization/",
	"title": "정규화",
	"tags": ["Normalization"],
	"description": "",
	"content": "정규화 / Normalization 정규화는 왜 필요한가 ? 한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다. 또 중복된 정보로 인해 갱신 이상 이 발생하게 된다. 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게 되는 것이다. 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다.\n갱신 이상  삽입 이상(insertion anomalies) 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점을 말한다. 삭제 이상(deletion anomalies) 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점을 말한다. 수정(갱신)이상(modification anomalies) 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점을 말한다.  정규화란 ? 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 좀 더 구체적으로는 불만족스러운 나쁜 릴레이션의 애트리뷰트들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 말한다. 정규화 과정을 거치게 되면 정규형을 만족하게 된다. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, … 등이 존재한다.\n\u0026ldquo;나쁜\u0026rdquo; 릴레이션은 어떻게 파악하는가? 엔티티를 구성하고 있는 애트리뷰트 간에 함수적 종속성(Functional Dependency)을 판단한다. 판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용된다. 즉, 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 따라 정규형이 정의되고, 그 정규형을 만족하지 못하는 정규형을 나쁜 릴레이션으로 파악한다.\n함수적 종속성이란 무엇인가? 함수적 종속성이란 애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종이다. X 와 Y 를 임의의 애트리뷰트 집합이라고 할 때, X 의 값이 Y 의 값을 유일하게(unique) 결정한다면 \u0026ldquo;X 는 Y 를 함수적으로 결정한다\u0026quot;라고 한다. 함수적 종속성은 실세계에서 존재하는 애트리뷰트들 사이의 제약조건으로부터 유도된다. 또한 각종 추론 규칙에 따라서 애트리뷰트들간의 함수적 종속성을 판단할 수 있다.\n애트리뷰트들의 관계로부터 추론된 함수적 종속성들을 기반으로 추론 가능한 모든 함수적 종속성들의 집합을 폐포라고 한다.\n 각각의 정규형은 어떠한 조건을 만족해야 하는가?  분해의 대상인 분해 집합 D 는 무손실 조인 을 보장해야 한다. 분해 집합 D 는 함수적 종속성을 보존해야 한다.  제 1 정규형 애트리뷰트의 도메인이 오직 원자값만을 포함하고, 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다. 즉, 복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비 원자적인 애트리뷰트들을 허용하지 않는 릴레이션 형태를 말한다.\n제 2 정규형 모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 완전 함수적 종속이면 제 2 정규형을 만족한다고 볼 수 있다. 완전 함수적 종속이란 X -\u0026gt; Y 라고 가정했을 때, X 의 어떠한 애트리뷰트라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태를 말한다.\n제 3 정규형 어떠한 비주요 애트리뷰트도 기본키에 대해서 이행적으로 종속되지 않으면 제 3 정규형을 만족한다고 볼 수 있다. 이행 함수적 종속이란 X - \u0026gt;Y, Y -\u0026gt; Z의 경우에 의해서 추론될 수 있는 X -\u0026gt; Z의 종속관계를 말한다. 즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.\nBCNF(Boyce-Codd) 정규형 여러 후보 키가 존재하는 릴레이션에 해당하는 정규화 내용이다. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는데 의미가 있다. 비주요 애트리뷰트가 후보키의 일부를 결정하는 분해하는 과정을 말한다.\n각 정규형은 그의 선행 정규형보다 더 엄격한 조건을 갖는다.\n 모든 제 2 정규형 릴레이션은 제 1 정규형을 갖는다. 모든 제 3 정규형 릴레이션은 제 2 정규형을 갖는다. 모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖는다.  수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것이다.\n 정규화에는 어떠한 장점이 있는가?  데이터베이스 변경 시 이상 현상(Anomaly) 제거 위에서 언급했던 각종 이상 현상들이 발생하는 문제점을 해결할 수 있다. 데이터베이스 구조 확장 시 재 디자인 최소화 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다. 이는 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되며 응용프로그램의 생명을 연장시킨다. 사용자에게 데이터 모델을 더욱 의미있게 제공 정규화된 테이블들과 정규화된 테이블들간의 관계들은 현실 세계에서의 개념들과 그들간의 관계들을 반영한다.  정규화의 단점은 없는가 ? 릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로 인해 질의에 대한 응답 시간이 느려질 수 있다. 조금 덧붙이자면, 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것이다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.\n정규화 단점의 대응책 ? 조희를 하는 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우에 반정규화를 적용하는 전략이 필요하다.\n반정규화(De-normalization, 비정규화) 반정규화는 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상 및 개발과 운영의 단순화를 위해 중복 통합, 분리 등을 수행하는 데이터 모델링 기법 중 하나이다. 디스크 I/O 량이 많아서 조회 시 성능이 저하되거나, 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나, 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다. 일반적으로 조회에 대한 처리 성능이 중요하다고 판단될 때 부분적으로 반정규화를 고려하게 된다.\n무엇이 반정규화의 대상이 되는가?  자주 사용되는 테이블에 액세스하는 프로세스의 수가 가장 많고, 항상 일정한 범위만을 조회하는 경우 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우 테이블에 지나치게 조인을 많이 사용하게 되어 데이터를 조회하는 것이 기술적으로 어려울 경우  반정규화 과정에서 주의할 점은? 반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다. 또한 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.\n Reference  https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94 https://minimax95.tistory.com/entry/%EC%A0%95%EA%B7%9C%ED%99%94Normalization-%EA%B0%9C%EB%85%90%EA%B3%BC-%EA%B8%B0%EB%B3%B8-%EA%B3%BC%EC%A0%95 https://velog.io/@wldus9503/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%A0%95%EA%B7%9C%ED%99%94Normalization%EB%9E%80  "
},
{
	"uri": "/basics_of_computer_science/operating_system/cache/",
	"title": "Cache",
	"tags": ["Cache", "Locality"],
	"description": "",
	"content": "Cache 캐시 메모리는 속도가 빠른 장치와 느린 장치간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다. 이러한 역할을 수행하기 위해서는 CPU 가 어떤 데이터를 원할 것인가를 어느 정도 예측할 수 있어야 한다. 캐시의 성능은 작은 용량의 캐시 메모리에 CPU 가 이후에 참조할, 쓸모 있는 정보가 어느 정도 들어있느냐에 따라 좌우되기 때문이다.\n이 때 적중율(Hit rate) 을 극대화 시키기 위해 데이터 지역성(Locality) 의 원리를 사용한다. 지역성의 전제조건으로 프로그램은 모든 코드나 데이터를 균등하게 Access 하지 않는다는 특성을 기본으로 한다. 즉, Locality란 기억 장치 내의 정보를 균일하게 Access 하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성인 것이다.\n이 데이터 지역성은 대표적으로 시간 지역성(Temporal Locality)과 공간 지역성(Spatial Locality)으로 나뉜다.\n 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성. 공간 지역성 : 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성  Caching line 언급했듯이 캐시(cache)는 프로세서 가까이에 위치하면서 빈번하게 사용되는 데이터를 놔두는 장소이다. 하지만 캐시가 아무리 가까이 있더라도 찾고자 하는 데이터가 어느 곳에 저장되어 있는지 몰라 모든 데이터를 순회해야 한다면 시간이 오래 걸리게 된다. 즉, 캐시에 목적 데이터가 저장되어 있다면 바로 접근하여 출력할 수 있어야 캐시가 의미 있어진다는 것이다.\n그렇기 때문에 캐시에 데이터를 저장할 때 특정 자료구조를 사용하여 묶음으로 저장하게 되는데 이를 캐싱 라인 이라고 한다. 프로세스는 다양한 주소에 있는 데이터를 사용하므로 빈번하게 사용하는 데이터의 주소 또한 흩어져 있다. 따라서 캐시에 저장하는 데이터에는 데이터의 메모리 주소 등을 기록해 둔 태그를 달아놓을 필요가 있다. 이러한 태그들의 묶음을 캐싱 라인이라고 하고 메모리로부터 가져올 때도 캐싱 라인을 기준으로 가져온다. 종류로는 대표적으로 세 가지 방식이 존재한다.\n Full Associative  인덱스가 모든 공간을 가리키는 경우. 충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느리다.   Set Associative  인덱스가 가리키는 공간이 두 개 이상인 경우. n-way set associative 캐시라고 부른다   Direct Map  인덱스가 가리키는 공간이 하나인 경우. 처리가 빠르지만 충돌 발생이 잦다     Reference  https://parksb.github.io/article/29.html  "
},
{
	"uri": "/java/final/",
	"title": "Final",
	"tags": [],
	"description": "",
	"content": "Final   final class\n 다른 클래스에서 상속하지 못한다.    final method\n 다른 메소드에서 오버라이딩하지 못한다.    final variable\n 변하지 않는 상수값이 되어 새로 할당할 수 없는 변수가 된다.    추가적으로 혼동할 수 있는 두 가지를 추가해봤다.\n  finally\n try-catch or try-catch-resource 구문을 사용할 때, 정상적으로 작업을 한 경우와 에러가 발생했을 경우를 포함하여 마무리 해줘야하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록이다.    finalize()\n keyword 도 아니고 code block 도 아닌 메소드이다. GC에 의해 호출되는 함수로 절대 호출해서는 안 되는 함수이다. Object 클래스에 정의되어 있으며 GC 가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없다. 또한 finalize() 메소드가 오버라이딩 되어 있으면 GC 가 이루어질 때 바로 Garbage Collecting 되지 않는다. GC 가 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있다.    "
},
{
	"uri": "/basics_of_computer_science/network/http_methods/",
	"title": "HTTP Methods",
	"tags": ["HTTP", "HTTP Methods", "GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"],
	"description": "",
	"content": "HTTP Methods HTTP는 요청 메서드를 정의하여, 주어진 리소스에 수행하길 원하는 행동을 나타냅니다.\n간혹 요청 메서드를 \u0026ldquo;HTTP 동사\u0026quot;라고 부르기도 합니다.\n각각의 메서드는 서로 다른 의미를 구현하지만, 일부 기능은 메서드 집합 간에 서로 공유하기도 합니다.\n이를테면 응답 메서드는 안전하거나, 캐시 가능하거나, 멱등성을 가질 수 있습니다.\n GET GET 메서드는 특정 리소스의 표시를 요청합니다. GET을 사용하는 요청은 오직 데이터를 받기만 합니다.\nSyntax : GET /index.html\n HEAD HEAD 메서드는 GET 메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않습니다.\nHEAD 메서드에 대한 응답은 본문을 가져선 안되며, 본문이 존재하더라도 무시해야 합니다. 그러나, Content-Length처럼 본문 콘텐츠를 설명하는 개체 헤더는 포함할 수 있습니다. 이 때, 개체 헤더는 비어있어야 하는 HEAD의 본문과는 관련이 없고, 대신 GET 메서드로 동일한 리소스를 요청했을 때의 본문을 설명합니다.\nHEAD 요청의 응답이 캐시했던 이전 GET 메서드의 응답을 유효하지 않다고 표시할 경우, 새로운 GET 요청을 생성하지 않더라도 캐시를 무효화합니다.\nSyntax : HEAD /index.html\n POST POST 메서드는 특정 리소스에 엔티티를 제출할 때 쓰입니다.\nHTTP POST 메서드는 서버로 데이터를 전송합니다. 요청 본문의 유형은 Content-Type 헤더로 나타냅니다.\nPUT과 POST의 차이는 멱등성으로, PUT은 멱등성을 가집니다. PUT은 한 번을 보내도, 여러 번을 연속으로 보내도 같은 효과를 보입니다. 즉, 부수 효과(side effect)가 없습니다.\nPOST 요청은 보통 HTML 양식을 통해 서버에 전송하며, 서버에 변경사항을 만듭니다. 이 경우의 콘텐츠 유형(Content-Type)은 요소의 enctype 특성이나 , 요소의 formenctype 특성 안에 적당한 문자열을 넣어 결정합니다.\nPOST 요청을 HTML 양식 외의 다른 방법(XMLHttpRequest 등)으로 전송할 땐 요청의 본문이 어떤 형태도 취할 수 있습니다. HTTP 1.1 규격에 정의된 바와 같이, POST는 다음의 기능을 포함하는 균일한 메서드를 허용하도록 설계되었습니다.\nSyntax : POST /index.html\n PUT PUT 메서드는 목적 리소스 모든 현재 표시를 요청 payload로 바꿉니다.\nHTTP PUT 메서드는 요청 페이로드를 사용해 새로운 리소스를 생성하거나, 대상 리소스를 나타내는 데이터를 대체합니다.\nPUT과 POST의 차이는 멱등성으로, PUT은 멱등성을 가집니다. PUT은 한 번을 보내도, 여러 번을 연속으로 보내도 같은 효과를 보입니다. 즉, 부수 효과가 없습니다.\nSyntax : PUT /new.html HTTP/1.1\n응답 대상 리소스를 나타내는 데이터가 없고, PUT 요청이 성공적으로 하나를 새로 생성한 경우, 출처 서버는 반드시 사용자 에이전트에게 201 (Created) 응답을 보내 해당 사항을 알려줘야 합니다.\n HTTP/1.1 201 Created Content-Location: /new.html  대상 리소스를 나타내는 데이터가 있고, 이를 요청에 포함된 자료에 준하여 성공적으로 수정했다면, 출처 서버는 반드시 200 (OK) 또는 204 (No Content) 응답을 보내 성공을 알려줘야 합니다.\n HTTP/1.1 204 No Content Content-Location: /existing.html   DELETE DELETE 메서드는 특정 리소스를 삭제합니다.\nSyntax : DELETE /file.html HTTP/1.1\n응답 DELETE 메서드를 성공적으로 적용한 후에 사용할 수 있는 응답 상태 코드는 다음과 같이 몇 가지가 있습니다.\n 아마도 명령을 성공적으로 수행할 것 같으나 아직은 실행하지 않은 경우 202 (Accepted) 상태 코드. 명령을 수행했고 더 이상 제공할 정보가 없는 경우 204 (No Content) 상태 코드. 명령을 수행했고 응답 메시지가 이후의 상태를 설명하는 경우 200 (OK) 상태 코드.   CONNECT CONNECT 메서드는 목적 리소스로 식별되는 서버로의 터널을 맺습니다.\nHTTP CONNECT 메소드는 요청한 리소스에 대해 양방향 연결을 시작하는 메소드입니다. 이는 터널을 열기 위해서 사용될 수 있습니다.\n예를 들어, CONNECT 메소드는 SSL (HTTPS)를 사용하는 웹사이트에 접속하는데 사용될 수 있습니다. 클라이언트는 원하는 목적지와의 TCP 연결을 HTTP 프록시 서버에 요청합니다. 그러면 서버는 클라이언트를 대신하여 연결의 생성을 진행합니다. 한번 서버에 의해 연결이 수립되면, 프록시 서버는 클라이언트에 오고가는 TCP 스트림을 계속해서 프록시합니다.\nCONNECT는 홉바이홉 메소드입니다.\nSyntax : CONNECT www.example.com:443 HTTP/1.1\n OPTIONS OPTIONS 메서드는 목적 리소스의 통신을 설정하는 데 쓰입니다.\nHTTP OPTIONS method 는 목표 리소스와의 통신 옵션을 설명하기 위해 사용됩니다. 클라이언트는 OPTIONS 메소드의 URL을 특정지을 수 있으며, aterisk(*) 를 통해 서버 전체를 선택할 수 있습니다.\nSyntax : OPTIONS /index.html HTTP/1.1\nSyntax : OPTIONS * HTTP/1.1\nEx) curl을 이용하여 OPTIONS 요청을 서버에 보냄으로써 서버에서 지원하는 method를 확인할 수 있다.\nSyntax : curl -X OPTIONS http://example.org -i\n TRACE TRACE 메서드는 목적 리소스의 경로를 따라 메시지 loop-back 테스트를 합니다.\nSyntax : TRACE /index.html\n PATCH PATCH 메서드는 리소스의 부분만을 수정하는 데 쓰입니다.\nHTTP PUT 메소드는 문서 전체의 완전한 교체만을 허용합니다. 반면 PATCH 메소드는 PUT 메소드와 달리 멱등성을 가지지 않는데, 이는 동일한 patch 요청이 다른 결과를 야기할 수도 있음을 뜻합니다. 하지만 PATCH를 PUT과 같은 방식으로 사용함으로써 멱등성을 가지게 할 수도 있습니다.\nPATCH (혹은 PUT)는 다른 리소스에게 부수효과(side-effects)를 일으킬 가능성이 있습니다.\nSyntax : PATCH /file.txt HTTP/1.1\n Reference  https://developer.mozilla.org/ko/docs/Web/HTTP/Methods  "
},
{
	"uri": "/basics_of_computer_science/database/statement/",
	"title": "Statement",
	"tags": ["Statement", "PreparedStatement"],
	"description": "",
	"content": "Statement 와 PreparedStatement  PreparedStatement 와 Statement의 가장 큰 차이점은 캐시(cache) 사용여부이다\n  쿼리 문장 분석 컴파일 실행  Statement를 사용하면 매번 쿼리를 수행할 때마다 1 ~ 3 단계를 거치게 되고, PreparedStatement는 처음 한 번만 세 단계를 거친 후 캐시에 담아 재사용을 한다는 것이다.\n만약 동일한 쿼리를 반복적으로 수행한다면 PreparedStatment가 DB에 훨씬 적은 부하를 주며, 성능도 좋다.\nPreparedStatement를 사용해야 하는 경우 사용자 입력값으로 쿼리를 생성하는 경우  사용자에의해 입력되는 값을 가지고 SQL 작업을 할 경우 statement를 사용한다면 다음과 같이 될 것이다  java\r\rString content = request.getParameter(\u0026#34;content\u0026#34;); stmt= conn.createStatement(); stmt.executeUpdate(\u0026#34;INSERT INTO TEST_TABLE (CONTENT) VALUES(\u0026#39;\u0026#34;+content+\u0026#34;\u0026#39;); \r\r\r\r사용자가 제대로 입력 하였다면 상관 없지만 content값에 \u0026ldquo;AA\u0026rsquo;AA\u0026quot;를 입력하였다면?\nstmt.executeUpdate(\u0026ldquo;INSERT INTO TEST_TABLE (CONTENT) VALUES('\u0026quot;+content+\u0026quot;'); 에서 에러가 발생할 것이다.\n즉 SQL문은 다음과 같이 되는 것이다. INSERT INTO TEST_TABLE (CONTENT) VALUES(\u0026lsquo;AA\u0026rsquo;AA\u0026rsquo;);\n이를 다음과 같이 수정한다면 위와같은 에러나 장애를 원천적으로 봉쇄할 수 있다\njava\r\rpstmt = conn.preapreStatement(\u0026#34;SELECT * FROM TEST_TABLE WHERE CONTENT = :content\u0026#34;); pstmt.setString(1, content); pstmt.executeUpdate(); \r\r\r\r이는 content값이 \u0026ldquo;'\u0026ldquo;가 들어왔다 하더라도 알아서 파싱 해주기 때문이다.\n고로 사용자 입력 값으로 쿼리를 바인딩 할 경우에는 필히 pstmt를 사용하도록 하자!\n쿼리 반복수행 작업일 경우 일반적으로 반복 수행 작업을 할 경우 아래와 같이 코딩 하게 된다.\n  Statement 사용 java\r\rfor (int i = 0; i \u0026lt; 100000; i++) { stmt.executeUpdate(\u0026#34;INSERT INTO TEST_TABLE VALUES(\u0026#39;\u0026#34;+content+\u0026#34;\u0026#39;); } \r\r\r\r  PreparedStatement 사용 java\r\rpstmt = conn.preapreStatement(\u0026#34;INSERT INTO TEST_TABLE VALUES(?)\u0026#34;); for (int i = 0; i \u0026lt; 10000; i++) { pstmt.setString(1, content+i); pstmt.executeUpdate(); } \r\r\r\r  DB의 종류에 따라 상황이 달라진다.\n일반적으로 위와같은 코딩을 할 경우 2)경우가 1)보다 더 좋은 성능을 보인다고 알려져 있다.\n즉 자바의 PreparedStatement의 사용은 오라클 DB에서 bind변수를 사용하도록 함으로 해서 DB서버에 미리 준비된 SQL을 사용하게 되고 파싱과정을 생략하기 때문에 결국 DB리소스를 효율적으로 사용하도록 하는 방법이 된다.\n하지만 이것이 DB서버에 따라 다르다. MySql같은 경우는 1)과2)의 성능차이가 거의 나지 않는다.\n 적당한 PreparedStatement의 사용\n 위와같은 이유로 PreparedStatement가 좋다! 모든 쿼리를 PreparedStatement로 하자! 만약 이와 같이 된다면 또다른 문제가 생긴다.\n각 DB마다 SQL캐싱할 수 있는 한계가 있기 때문에 정작 성능상 캐싱되어야 할 쿼리가 그렇지 않은 쿼리 때문에 캐싱이 안 될 수 있기때문에 꼭 필요한 문장만 PreparedStatement를 쓰는것을 권고한다.\nStatement를 받드시 사용해야 하는 경우 Dynamic SQL을 사용할 경우 Dynamic SQL을 사용한다면 매번 조건절이 틀려지게 됨으로 statement가 좋다.\n즉 캐싱의 장점을 잃어버립니다.\n또한 Dynamic SQL일 경우 코딩도 Statement가 훨신 편하다.\n Reference  https://java.ihoney.pe.kr/76  "
},
{
	"uri": "/basics_of_computer_science/database/",
	"title": "데이터베이스",
	"tags": [],
	"description": "",
	"content": "데이터베이스 관련된 내용입니다.\n \rDatabase\r\rDatabase 데이터베이스를 사용하는 이유 데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. (현재도 부분적으로 사용되고 있다.) 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다. 이 때의 문제점은 데이터 종속성 문제와 중복성, 데이터 무결성이다. 데이터베이스의 특징 데이터의 독립성 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다. 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.\n\rIndex\r\rIndex 인덱스(Index)란 무엇인가? 인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인이라고 할 수 있다. 이 비유를 그대로 가져와서 인덱스를 살펴본다면 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 될 것이다. DBMS 도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다. DBMS 의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다.\n\r정규화\r\r정규화 / Normalization 정규화는 왜 필요한가 ? 한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며, 저장 공간을 낭비하게 된다. 또 중복된 정보로 인해 갱신 이상 이 발생하게 된다. 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게 되는 것이다. 이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이다. 갱신 이상 삽입 이상(insertion anomalies) 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점을 말한다.\n\rStatement\r\rStatement 와 PreparedStatement PreparedStatement 와 Statement의 가장 큰 차이점은 캐시(cache) 사용여부이다 쿼리 문장 분석 컴파일 실행 Statement를 사용하면 매번 쿼리를 수행할 때마다 1 ~ 3 단계를 거치게 되고, PreparedStatement는 처음 한 번만 세 단계를 거친 후 캐시에 담아 재사용을 한다는 것이다. 만약 동일한 쿼리를 반복적으로 수행한다면 PreparedStatment가 DB에 훨씬 적은 부하를 주며, 성능도 좋다. PreparedStatement를 사용해야 하는 경우 사용자 입력값으로 쿼리를 생성하는 경우 사용자에의해 입력되는 값을 가지고 SQL 작업을 할 경우 statement를 사용한다면 다음과 같이 될 것이다 java\rString content = request.\n\rTransaction\r\r트랜잭션 / Transaction 트랜잭션(Transaction)이란 ? 트랜잭션은 작업의 완전성 을 보장해주는 것이다. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다. 사용자의 입장에서는 작업의 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다. 트랜잭션과 Lock 잠금(Lock)과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.\n\rNoSQL\r\rNoSQL 관계형 데이터 모델을 지양 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다. 종류마다 쓰기/읽기 성능 특화, 2 차 인덱스 지원, 오토 샤딩 지원 같은 고유한 특징을 가진다. 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용한다. 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위하여 데이터 복제 등의 방법으로 관계형 데이터베이스가 제공하지 못하는 성능과 특징을 제공한다. CAP 이론 일관성(Consistency) 일관성은 동시성 또는 동일성이라고도 하며 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의미한다.\n\r"
},
{
	"uri": "/java/polymorphism/",
	"title": "Polymorphism",
	"tags": [],
	"description": "",
	"content": "Overriding vs Overloading 둘 다 다형성을 높여주는 개념이고 비슷한 이름이지만, 전혀 다른 개념이라고 봐도 무방할 만큼 차이가 있다(오버로딩은 다른 시그니쳐를 만든다는 관점에서 다형성으로 보지 않는 의견도 있다). 공통점으로는 같은 이름의 다른 함수를 호출한다는 것이다.\n오버라이딩(Overriding) 상위 클래스 혹은 인터페이스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것을 의미한다. 자바의 경우는 오버라이딩 시 동적바인딩된다.\n아래와 같은 경우, SuperClass의 fun이라는 인터페이스를 통해 SubClass의 fun이 실행된다.\nSuperClass object = new SubClass(); object.fun(); 오버로딩(Overloading) 메소드의 이름과 return 타입은 동일하지만, 매개변수만 다른 메소드를 만드는 것을 의미한다. 다양한 상황에서 메소드가 호출될 수 있도록 한다. 언어마다 다르지만, 자바의경우 오버로딩은 다른 시그니쳐를 만드는 것으로, 아예 다른함수를 만든것과 비슷하다고 생각하면 된다. 시그니쳐가 다르므로 정적바인딩으로 처리 가능하며, 자바의 경우 정적으로 바인딩된다.\n예) 아래와 같은 경우,fun(SuperClass super)이 실행된다.\nmain(blabla) { SuperClass object = new SubClass(); fun(object); } fun(SuperClass super) { blabla.... } fun(SubClass sub) { blabla.... } "
},
{
	"uri": "/basics_of_computer_science/database/transaction/",
	"title": "Transaction",
	"tags": ["Transaction", "Lock"],
	"description": "",
	"content": "트랜잭션 / Transaction 트랜잭션(Transaction)이란 ? 트랜잭션은 작업의 완전성 을 보장해주는 것이다. 즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다. 사용자의 입장에서는 작업의 논리적 단위로 이해를 할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.\n트랜잭션과 Lock 잠금(Lock)과 트랜잭션은 서로 비슷한 개념 같지만 사실 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 여기서 자원은 레코드나 테이블을 말한다. 이와는 조금 다르게 트랜잭션은 꼭 여러 개의 변경 작업을 수행하는 쿼리가 조합되었을 때만 의미있는 개념은 아니다. 트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것이다. 예를 들면 HW 에러 또는 SW 에러와 같은 문제로 인해 작업에 실패가 있을 경우, 특별한 대책이 필요하게 되는데 이러한 문제를 해결하는 것이다.\n트랜잭션의 특성 트랜잭션은 어떠한 특성을 만족해야할까? Transaction 은 다음의 ACID 라는 4 가지 특성을 만족해야 한다.\n 원자성(Atomicity)  만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.   일관성(Consistency)  트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.   고립성(Isolation)  각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.   지속성(Durability)  트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.     트랜잭션의 상태 graph LR;\rA(Begin Transaction) -- B(Active)\rB -- C(Partially Committed)\rC -- D(Committed)\rC -- E(Failed)\rB -- E(Failed)\rE -- F(Aborted)\r\rActive 트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다.\nFailed 트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태를 말한다.\nPartially Committed 트랜잭션의 Commit 명령이 도착한 상태. 트랜잭션의 commit이전 sql문이 수행되고 commit만 남은 상태를 말한다.\nCommitted 트랜잭션 완료 상태. 트랜잭션이 정상적으로 완료된 상태를 말한다.\nAborted 트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.\nPartially Committed 와 Committed 의 차이점 Commit 요청이 들어오면 상태는 Partial Commited 상태가 된다. 이후 Commit을 문제없이 수행할 수 있으면 Committed 상태로 전이되고, 만약 오류가 발생하면 Failed 상태가 된다. 즉, Partial Commited는 Commit 요청이 들어왔을때를 말하며, Commited는 Commit을 정상적으로 완료한 상태를 말한다.\n 트랜잭션을 사용할 때 주의할 점 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화하라는 의미다. 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.\n교착상태 복수의 트랜잭션을 사용하다보면 교착상태가 일어날수 있다. 교착상태란 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를 교착상태라고 한다.\n교착상태의 예(MySQL) MySQL MVCC에 따른 특성 때문에 트랜잭션에서 갱신 연산(Insert, Update, Delete)를 실행하면 잠금을 획득한다. (기본은 행에 대한 잠금)\ngraph LR;\rA(Resource A) -- |Owned By| B(Resource B) B(Transaction 2) -- |Waiting for| C(Resource B) C(Resource B) -- |Owned By| D(Transaction 1) D(Transaction 1) -- |Waiting for| A(Resource A)\t\r트랜잭션 1이 테이블 B의 첫번째 행의 잠금을 얻고 트랜잭션 2도 테이블 A의 첫번째 행의 잠금을 얻었다고 하자.\nsql\r\rTransaction 1\u0026gt; create table B (i1 int not null primary key) engine = innodb; Transaction 2\u0026gt; create table A (i1 int not null primary key) engine = innodb; Transaction 1\u0026gt; start transaction; insert into B values(1); Transaction 2\u0026gt; start transaction; insert into A values(1); \r\r\r\r트랜잭션을 commit 하지 않은채 서로의 첫번째 행에 대한 잠금을 요청하면\nsql\r\rTransaction 1\u0026gt; insert into A values(1); Transaction 2\u0026gt; insert into B values(1); ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction \r\r\r\rDeadlock 이 발생한다. 일반적인 DBMS는 교착상태를 독자적으로 검출해 보고한다.\n교착 상태의 빈도를 낮추는 방법  트랜잭션을 자주 커밋한다. 정해진 순서로 테이블에 접근한다. 위에서 트랜잭션 1 이 테이블 B -\u0026gt; A 의 순으로 접근했고, 트랜잭션 2 는 테이블 A -\u0026gt; B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다. 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다. 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다, 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성을 떨어지지만 교착상태를 회피할 수 있다.   Reference  https://coding-factory.tistory.com/226 https://mommoo.tistory.com/62 https://devuna.tistory.com/30 http://wiki.hash.kr/index.php/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98  "
},
{
	"uri": "/basics_of_computer_science/design_pattern/",
	"title": "디자인패턴",
	"tags": [],
	"description": "",
	"content": "디자인패턴에 관련된 내용입니다.\n \rRestful Api\r\rRestful Api 란 ? REST API(RESTful API, 레스트풀 API)란 REST 아키텍처의 제약 조건을 준수하는 애플리케이션 프로그래밍 인터페이스를 뜻합니다. REST는 Representational State Transfer의 줄임말입니다. API 또는 애플리케이션 프로그래밍 인터페이스(Application Programming Interface)는 애플리케이션 소프트웨어를 구축하고 통합하는 정의 및 프로토콜 세트입니다. 때때로 API는 정보 제공자와 정보 사용자 간의 계약으로 지칭되며 소비자에게 필요한 콘텐츠(호출)와 생산자에게 필요한 콘텐츠(응답)를 구성합니다. 즉, 컴퓨터나 시스템과 상호 작용하여 정보를 검색하거나 기능을 수행하고자 할 때 API는 사용자가 원하는 것을 시스템에 전달할 수 있게 지원하여 시스템이 이 요청을 이해하고 이행하도록 할 수 있습니다.\n\rMVC\r\rMVC 아키텍쳐에 대한 이해 MVC의 각 컴포넌트의 역할 Controller(컨트롤러) 클라이언트의 요청을 받았을 때, 그 요청에 대해 실제 업무를 수행하는 모델 컴포넌트를 호출한다. 또한 클라이언트가 보낸 데이터가 있다면, 모델에 전달하기 쉽게 데이터를 가공한다. 모델이 업무를 마치면 그 결과를 뷰에게 전달한다. Model (모델) 컨트롤러가 호출할 때, 요청에 맞는 역할을 수행한다. 비즈니스 로직을 구현하는 영역으로 응용프로그램에서 데이터를 처리하는 부분이다 비즈니스 로직이란 업무에 필요한 데이터처리를 수행하는 응용프로그램의 일부라고 할 수 있다.\n\r"
},
{
	"uri": "/java/access-modifier/",
	"title": "Access Modifier",
	"tags": [],
	"description": "",
	"content": "Access Modifier 변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java 의 예약어를 의미하며 총 네 가지 종류가 존재한다.\n  public 어떤 클래스에서라도 접근이 가능하다.\n  protected 클래스가 정의되어 있는 해당 패키지 내 그리고 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근이 가능하다.\n  (default) 클래스가 정의되어 있는 해당 패키지 내에서만 접근이 가능하도록 접근 범위를 제한한다.\n  private 정의된 해당 클래스에서만 접근이 가능하도록 접근 범위를 제한한다.\n  "
},
{
	"uri": "/linux/basiccommand/",
	"title": "Basic Command",
	"tags": [],
	"description": "",
	"content": "Basic Linux Commands pwd (print working directory) 현재 작업중인 디렉토리 정보 출력\n$ pwd /home/itholic cd (change directory) 경로 이동 절대 경로와 상대 경로로 이동 가능하다.\n$ cd /home/itholic/mydir $ pwd /home/itholic/mydir $ cd .. $ pwd /home/itholic ls (list) 디렉토리 목록 확인\n$ ls testfile1 testfile2 testfile3 $ ls -l total 0 -rw-r--r-- 1 itholic 197121 0 11월 6 22:08 testfile1 -rw-r--r-- 1 itholic 197121 0 11월 6 22:08 testfile2 -rw-r--r-- 1 itholic 197121 0 11월 6 22:08 testfile3 $ ls -a ./ ../ testfile1 testfile2 testfile3 $ ls -al total 4 drwxr-xr-x 1 itholic 197121 0 11월 6 22:08 ./ drwxr-xr-x 1 itholic 197121 0 11월 6 22:08 ../ -rw-r--r-- 1 itholic 197121 0 11월 6 22:08 testfile1 -rw-r--r-- 1 itholic 197121 0 11월 6 22:08 testfile2 -rw-r--r-- 1 itholic 197121 0 11월 6 22:08 testfile3 cp (copy) 파일 혹은 디렉토리를 복사\n디렉토리를 복사할때는 -r 옵션을 주어야함\n$ ls testdir/ testfile $ cp testfile1 testfile_cp $ ls testdir/ testfile testfile_cp $ cp -r testdir testdir_cp $ ls testdir/ testdir_cp/ testfile testfile_cp mv (move) 파일 혹은 디렉토리 이동\n실제로 원하는 위치로 이동할때도 사용하지만, 이름을 변경하는 용도로도 사용한다.\ncp와는 달리 디렉토리를 이동할때도 별다른 옵션이 필요 없다.\n$ ls testdir/ testfile $ mv testfile testfile_mv $ ls testdir/ testfile_mv $ mv testfile_mv testdir/ $ ls testdir/ $ ls testdir/ testfile mkdir (make directory) 디렉토리 생성\n-p 옵션을 주면 하위 디렉토리까지 한 번에 생성 가능\n아래 예제중 ls -R 옵션은 디렉토리의 하위목록까지 전부 보여주는 옵션인데,\n내 경우 실제로 많이 사용하진 않아서 ls 명령어에서 따로 설명하진 않았다.\nmkdir -p 옵션 예제에서 실제로 하위디렉토리가 생성되었다는 것을 보여주기 위해 사용하였다.\n$ ls testfile $ mkdir testdir $ ls testdir/ testfile $ mkdir -p a/b/c/d/e/ $ ls -R a/ a/: b/ a/b: c/ a/b/c: d/ a/b/c/d: e/ a/b/c/d/e: rm (remove) 파일이나 디렉토리를 삭제\n디렉토리를 삭제할때는 r 옵션을 주어야 한다.\n-f 옵션을 주면 사용자에게 삭제 여부를 묻지 않고 바로 삭제한다.\n디렉토리를 삭제할 때에는 하위 디렉토리까지 모두 삭제되므로 유의하자.\n$ ls testdir/ testfile1 testfile2 $ rm -f testfile1 $ ls testdir/ testfile2 $ rm -rf testdir/ $ ls testfile2 touch 파일이나 디렉토리의 최근 업데이트 일자를 현재 시간으로 변경한다.\n최근 업데이트 일자는 ls -l 명령을 통해 확인할 수 있다.\n아래 예제에서 ‘11월 6 22:08’ 이라고 쓰여진 부분이다.\n파일이나 디렉토리가 존재하지 않으면 빈 파일을 만든다.\n$ ls -l total 0 -rw-r--r-- 1 itholic 197121 0 11월 6 22:08 testfile1 $ touch testfile1 $ ls -l total 0 -rw-r--r-- 1 itholic 197121 0 11월 6 22:43 testfile1 $ touch testfile2 $ ls -l total 0 -rw-r--r-- 1 itholic 197121 0 11월 6 22:43 testfile1 -rw-r--r-- 1 itholic 197121 0 11월 6 22:44 testfile2 cat (concatenate) cat 명령은 활용 방법이 꽤나 다양하다.\n단순히 파일의 내용을 출력할 수도 있고,\n파일 여러개를 합쳐서 하나의 파일로 만들 수도 있다.\n그리고 기존 한 파일의 내용을 다른 파일에 덧붙일수도 있다.\n새로운 파일을 만들때에도 사용된다.\nfile1, file2, file3 파일에는 각각 간단하게 숫자 1, 2, 3 이 적혀있다.\n$ ls file1 file2 file3 $ cat file1 1 $ cat file2 2 $ cat file3 3 $ cat file1 file2 \u0026gt; file1_2 $ ls file1 file1_2 file2 file3 $ cat file1_2 1 2 $ cat file1 \u0026gt;\u0026gt; file2 $ cat file2 2 1 $ cat \u0026gt; file4 hello world (작성이 끝나면 ctrl +d 로 파일 저장)\n$ cat file4 hello world head 파일의 앞부분을 보고싶은 줄 수만큼 보여준다.\n옵션을 지정하지 않으면 파일 상위 10줄을 보여준다.\n$ cat testfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ head -3 testfile 1 2 3 $ head testfile 1 2 3 4 5 6 7 8 9 10 tail 파일의 뒷부분을 보고싶은 줄 수만큼 보여준다.\n옵션을 지정하지 않으면 파일 하위 10줄을 보여준다.\n참고로 -F 옵션을 주고 실행하면,\n파일 내용을 화면에 계속 띄워주고 파일이 변하게되면 새로운 업데이트된 내용을 갱신해준다.\n주로 실시간으로 내용이 추가되는 로그파일을 모니터링할때 유용하게 사용한다.\n$ cat testfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ tail -3 testfile 13 14 15 $ tail testfile 6 7 8 9 10 11 12 13 14 15 $ tail -F testfile 6 7 8 9 10 11 12 13 14 15 (명령어가 종료되지 않고 계속 해당 화면을 출력하며, 파일 내용 변경시 자동으로 갱신해준다)\nfind 특정 파일이나 디렉토리를 검색한다\n사용법이 앞의 명령어들에비해 살짝 복잡하므로, 기본 사용법을 언급하자면 다음과 같다.\nfind [검색경로] -name [파일명]\n파일명은 직접 풀 네임을 입력해도 되지만,\n다음 예제처럼 특정 조건을 적용해 검색할수도 있다.\n나같은 경우 주로 특정 확장자명을 찾기 위해 사용한다.\n$ ls dir1/ dir3/ file1 file3 picture1.jpg picture3.jpg dir2/ dir4/ file2 file4 picture2.jpg picture4.jpg $ find ./ -name \u0026#39;file1\u0026#39; ./file1 $ find ./ -name \u0026#34;*.jpg\u0026#34; ./picture1.jpg ./picture2.jpg ./picture3.jpg ./picture4.jpg 확장자가 .jpg인 파일을 찾았다.\n하지만 여기서 그치지 않고, 확장자가 .jpg인 파일만 찾아서 바로 삭제할수도 있다.\nexec 옵션을 사용해 다음과 같이 처리하면 된다.\n$ find ./ -name \u0026#34;*.jpg\u0026#34; -exec rm {} \\; $ ls dir1/ dir2/ dir3/ dir4/ file1 file2 file3 file4 그리고 다음과 같이 -type 옵션을 주면, 디렉토리나 파일만 지정해서 검색할수도 있다.\n$ find ./ -type d ./ ./dir1 ./dir2 ./dir3 ./dir4 $ find ./ -type f ./file1 ./file2 ./file3 ./file4 다음과 같이 wc -l 옵션과 같이 사용하면,\n특정 디렉토리에 find 조건에 맞는 결과 값이 몇개 존재하는지 숫자로 간편히 알아볼 수 있다.\n$ find ./ -type f | wc -l 4 지금처럼 파일 갯수가 4개밖에 없을땐 그냥 일일이 세면 되지만,\n파일이 수백, 수천, 수십만 개가 있을땐 아주 유용하다.\n마지막으로 아래 내용은 명령어가 조금 복잡하지만, 알아두면 유용해서 적어둔다.\n특정 조건에 해당하는 파일들의 내용을 전부 찾아서 바꾸는 것이다.\n예를들어 10만개의 파일이 있는데,\n그 중에 확장자가 .txt인 파일만 찾아내고,\ntxt 파일 안에 있는 ‘hi’ 라는 문자열을 ‘hello’로 바꾸려면 다음과 같이 하면 된다.\nfind ./ -name \u0026#34;*.txt\u0026#34; -exec sed -i \u0026#39;s/hi/hello/g\u0026#39; {} \\; 짧게 설명하자면,\n다음 sed 명령어는 testfile1.txt 이라는 파일의 모든 ‘hi’ 라는 문자열을 ‘hello’로 바꾸는 역할을 한다.\nsed -i \u0026#39;s/hi/hello/g\u0026#39; testfile1.txt 이를 find 명령과 조합하여 조건에 맞는 모든 파일에 대해 해당 명령을 수행할 수 있도록 응용한 것이다.\n"
},
{
	"uri": "/basics_of_computer_science/database/nosql/",
	"title": "NoSQL",
	"tags": ["NoSQL"],
	"description": "",
	"content": "NoSQL 관계형 데이터 모델을 지양 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.\n종류마다 쓰기/읽기 성능 특화, 2 차 인덱스 지원, 오토 샤딩 지원 같은 고유한 특징을 가진다. 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용한다. 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위하여 데이터 복제 등의 방법으로 관계형 데이터베이스가 제공하지 못하는 성능과 특징을 제공한다.\nCAP 이론 일관성(Consistency) 일관성은 동시성 또는 동일성이라고도 하며 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의미한다. 이것은 관계형 데이터베이스가 지원하는 가장 기본적인 기능이지만 일관성을 지원하지 않는 NoSQL 을 사용한다면 데이터의 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있다. 느슨하게 처리된다는 것은 데이터의 변경을 시간의 흐름에 따라 여러 노드에 전파하는 것을 말한다. 이러한 방법을 최종적으로 일관성이 유지된다고 하여 최종 일관성 또는 궁극적 일관성을 지원한다고 한다.\n각 NoSQL 들은 분산 노드 간의 데이터 동기화를 위해서 두 가지 방법을 사용한다. 첫번째로 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법이 있다. 그만큼 느린 응답시간을 보이지만 데이터의 정합성을 보장한다. 두번째로 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 다음, 특정 이벤트 또는 프로세스를 사용하여 노드로 데이터를 동기화하는 비동기식 방법이 있다. 빠른 응답시간을 보인다는 장점이 있지만, 쓰기 노드에 장애가 발생하였을 경우 데이터가 손실될 수 있다.\n가용성(Availability) 가용성이란 모든 클라이언트의 읽기와 쓰기 요청에 대하여 항상 응답이 가능해야 함을 보증하는 것이며 내고장성이라고도 한다. 내고장성을 가진 NoSQL 은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능하다.\n몇몇 NoSQL 은 가용성을 보장하기 위해 데이터 복제(Replication)을 사용한다. 동일한 데이터를 다중 노드에 중복 저장하여 그 중 몇 대의 노드가 고장나도 데이터가 유실되지 않도록 하는 방법이다. 데이터 중복 저장 방법에는 동일한 데이터를 가진 저장소를 하나 더 생성하는 Master-Slave 복제 방법과 데이터 단위로 중복 저장하는 Peer-to-Peer 복제 방법이 있다.\n네트워크 분할 허용성(Partition tolerance) 분할 허용성이란 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템은 정상적으로 동작해야 함을 의미한다.\n저장 방식에 따른 NoSQL 분류 1. Key-Value Model 가장 기본적인 형태의 NoSQL 이며 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 갖는다. 단순한 저장구조로 인하여 복잡한 조회 연산을 지원하지 않는다. 또한 고속 읽기와 쓰기에 최적화된 경우가 많다. 사용자의 프로필 정보, 웹 서버 클러스터를 위한 세션 정보, 장바구니 정보, URL 단축 정보 저장 등에 사용한다. 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 없다. ex) Redis\n2. Document Model 키-값 모델을 개념적으로 확장한 구조로 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다. 논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사하다. 키는 문서에 대한 ID 로 표현된다. 또한 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID 에 대한 인덱스를 생성한다. 문서 ID 에 대한 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다.\n대부분의 문서 모델 NoSQL 은 B 트리 인덱스를 사용하여 2 차 인덱스를 생성한다. B 트리는 크기가 커지면 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 떨어지게 된다. 그렇기 때문에 읽기와 쓰기의 비율이 7:3 정도일 때 가장 좋은 성능을 보인다. 중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용된다. ex) MongoDB\n3. Column Model 하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다.\n구글의 빅테이블이 대표적인 예로 차후 컬럼형 NoSQL 은 빅테이블의 영향을 받았다. 이러한 이유로 Row key, Column Key, Column Family 같은 빅테이블 개념이 공통적으로 사용된다. 저장의 기본 단위는 컬럼으로 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 이러한 컬럼들의 집합이 로우(Row)이며, 로우키(Row key)는 각 로우를 유일하게 식별하는 값이다. 이러한 로우들의 집합은 키 스페이스(Key Space)가 된다.\n대부분의 컬럼 모델 NoSQL 은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다. 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다. 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.\n Reference  https://namu.wiki/w/NoSQL https://jwprogramming.tistory.com/70 https://www.samsungsds.com/kr/insights/1232564_4627.html?referrer=https://www.google.com/  "
},
{
	"uri": "/basics_of_computer_science/algorithm/",
	"title": "알고리즘",
	"tags": [],
	"description": "",
	"content": "알고리즘에 관련된 내용입니다.\n \r"
},
{
	"uri": "/java/wrapper-class/",
	"title": "Wrapper class",
	"tags": [],
	"description": "",
	"content": "Wrapper class 기본 자료형(Primitive data type)에 대한 클래스 표현을 Wrapper class 라고 한다. Integer, Float, Boolean 등이 Wrapper class 의 예이다. int 를 Integer 라는 객체로 감싸서 저장해야 하는 이유가 있을까? 일단 컬렉션에서 제네릭을 사용하기 위해서는 Wrapper class 를 사용해줘야 한다. 또한 null 값을 반환해야만 하는 경우에는 return type 을 Wrapper class 로 지정하여 null을 반환하도록 할 수 있다. 하지만 이러한 상황을 제외하고 일반적인 상황에서 Wrapper class 를 사용해야 하는 이유는 객체지향적인 프로그래밍을 위한 프로그래밍이 아니고서야 없다. 일단 해당 값을 비교할 때, Primitive data type 인 경우에는 ==로 바로 비교해줄 수 있다. 하지만 Wrapper class 인 경우에는 .intValue() 메소드를 통해 해당 Wrapper class 의 값을 가져와 비교해줘야 한다.\nAutoBoxing JDK 1.5 부터는 AutoBoxing과 AutoUnBoxing을 제공한다. 이 기능은 각 Wrapper class 에 상응하는 Primitive data type 일 경우에만 가능하다.\nList\u0026lt;Integer\u0026gt; lists = new ArrayList\u0026lt;\u0026gt;(); lists.add(1); 우린 Integer라는 Wrapper class 로 설정한 collection 에 데이터를 add 할 때 Integer 객체로 감싸서 넣지 않는다. 자바 내부에서 AutoBoxing해주기 때문이다.\n"
},
{
	"uri": "/java/multi-thread/",
	"title": "Multi-Thread",
	"tags": [],
	"description": "",
	"content": "Multi-Thread 환경에서의 개발 개발을 시작하는 입장에서 멀티 스레드를 고려한 프로그램을 작성할 일이 별로 없고 실제로 부딪히기 힘든 문제이기 때문에 많은 입문자들이 잘 모르고 있는 부분 중 하나라고 생각한다. 하지만 이 부분은 정말 중요하며 고려하지 않았을 경우 엄청난 버그를 양산할 수 있기 때문에 정말 중요하다.\nField member 필드(field)란 클래스에 변수를 정의하는 공간을 의미한다. 이곳에 변수를 만들어두면 메소드 끼리 변수를 주고 받는 데 있어서 참조하기 쉬우므로 정말 편리한 공간 중 하나이다. 하지만 객체가 여러 스레드가 접근하는 싱글톤 객체라면 field 에서 상태값을 갖고 있으면 안된다. 모든 변수를 parameter 로 넘겨받고 return 하는 방식으로 코드를 구성해야 한다.\n동기화(Synchronized) 필드에 Collection 이 불가피하게 필요할 때는 어떠한 방법을 사용할까? Java 에서는 synchronized 키워드를 사용하여 스레드 간 race condition 을 통제한다. 이 키워드를 기반으로 구현된 Collection 들도 많이 존재한다. List를 대신하여 Vector를 사용할 수 있고, Map을 대신하여 HashTable을 사용할 수 있다. 하지만 이 Collection 들은 제공하는 API 가 적고 성능도 좋지 않다.\n기본적으로는 Collections라는 util 클래스에서 제공되는 static 메소드를 통해 이를 해결할 수 있다. Collections.synchronizedList(), Collections.synchronizedSet(), Collections.synchronizedMap() 등이 존재한다. JDK 1.7 부터는 concurrent package를 통해 ConcurrentHashMap이라는 구현체를 제공한다. Collections util 을 사용하는 것보다 synchronized 키워드가 적용된 범위가 좁아서 보다 좋은 성능을 낼 수 있는 자료구조이다.\nThreadLocal 스레드 사이에 간섭이 없어야 하는 데이터에 사용한다. 멀티스레드 환경에서는 클래스의 필드에 멤버를 추가할 수 없고 매개변수로 넘겨받아야 하기 때문이다. 즉, 스레드 내부의 싱글톤을 사용하기 위해 사용한다. 주로 사용자 인증, 세션 정보, 트랜잭션 컨텍스트에 사용한다.\n스레드 풀 환경에서 ThreadLocal 을 사용하는 경우 ThreadLocal 변수에 보관된 데이터의 사용이 끝나면 반드시 해당 데이터를 삭제해 주어야 한다. 그렇지 않을 경우 재사용되는 쓰레드가 올바르지 않은 데이터를 참조할 수 있다.\nThreadLocal 을 사용하는 방법은 간단하다.\n ThreadLocal 객체를 생성한다. ThreadLocal.set() 메서드를 이용해서 현재 스레드의 로컬 변수에 값을 저장한다. ThreadLocal.get() 메서드를 이용해서 현재 스레드의 로컬 변수 값을 읽어온다. ThreadLocal.remove() 메서드를 이용해서 현재 스레드의 로컬 변수 값을 삭제한다.  "
},
{
	"uri": "/java/",
	"title": "Java",
	"tags": [],
	"description": "",
	"content": "Chapter 2 Java Java에 관련된 내용입니다.\n\rCollection\r\r\rAnnotation\r\r\rGeneric\r\r\rFinal\r\r\rPolymorphism\r\r\rAccess Modifier\r\r\rWrapper class\r\r\rMulti-Thread\r\r\r"
},
{
	"uri": "/ci_cd/",
	"title": "CI/CD",
	"tags": [],
	"description": "",
	"content": "Chapter 3 CI/CD CI, CD 에 관한 내용입니다.\n Continuous Integration Continuous Delivery  \rCI\r\r\rCD\r\r\r"
},
{
	"uri": "/linux/",
	"title": "Linux",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Linux 리눅스에 관련된 내용입니다.\n\rConcept\r\r\rBasic Command\r\r\r"
},
{
	"uri": "/example_code/",
	"title": "Example Code",
	"tags": [],
	"description": "",
	"content": "Chapter 5 Example Code 예제 코드가 수록되어 있습니다.\n\rJava Code\r\r\r"
},
{
	"uri": "/roadmap/",
	"title": "Roadmap",
	"tags": [],
	"description": "",
	"content": "Chapter 6 RoadMap 로드맵 번역본 입니다.\n\rDevops\r\r\rBackend\r\r\rFrontend\r\r\r"
},
{
	"uri": "/tags/async/",
	"title": "Async",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/blocking/",
	"title": "Blocking",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/cache/",
	"title": "Cache",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/connect/",
	"title": "CONNECT",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/data/",
	"title": "Data",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/database/",
	"title": "Database",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/delete/",
	"title": "DELETE",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/dns/",
	"title": "DNS",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/fp/",
	"title": "FP",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/get/",
	"title": "GET",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/good-code/",
	"title": "Good Code",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/head/",
	"title": "HEAD",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "WideTNS Tech Blog. 본 사이트는 Go 기반의 정적 사이트 생성기 엔진인 Hugo로 만들어졌으며, Hugo-theme-learn 테마를 사용중입니다.\n본 사이트는 Google Chrome 에 최적화되어 있습니다.\n\r Main features  Basics of Computer Science Design Pattern Algorithm Roadmap  "
},
{
	"uri": "/tags/http/",
	"title": "HTTP",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/http-methods/",
	"title": "HTTP Methods",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/https/",
	"title": "HTTPS",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/index/",
	"title": "Index",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/ip/",
	"title": "IP",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/locality/",
	"title": "Locality",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/lock/",
	"title": "Lock",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/memory/",
	"title": "Memory",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/multiprocess/",
	"title": "MultiProcess",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/multithread/",
	"title": "MultiThread",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/mvc/",
	"title": "MVC",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/non-blocking/",
	"title": "Non-blocking",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/normalization/",
	"title": "Normalization",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/nosql/",
	"title": "NoSQL",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/oop/",
	"title": "OOP",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/options/",
	"title": "OPTIONS",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/paging/",
	"title": "Paging",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/paradigm/",
	"title": "Paradigm",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/patch/",
	"title": "PATCH",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/pcb/",
	"title": "PCB",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/post/",
	"title": "POST",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/pp/",
	"title": "PP",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/preparedstatement/",
	"title": "PreparedStatement",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/process/",
	"title": "Process",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/put/",
	"title": "PUT",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/restfulapi/",
	"title": "RestFulApi",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/scheduling/",
	"title": "Scheduling",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/segmentation/",
	"title": "Segmentation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/statement/",
	"title": "Statement",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/sync/",
	"title": "Sync",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/tcp/",
	"title": "TCP",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/tdd/",
	"title": "TDD",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/thread/",
	"title": "Thread",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/tips/",
	"title": "Tips",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/trace/",
	"title": "TRACE",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/transaction/",
	"title": "Transaction",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/udp/",
	"title": "UDP",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/virtual-memory/",
	"title": "Virtual Memory",
	"tags": [],
	"description": "",
	"content": ""
}]